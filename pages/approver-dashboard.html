<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>XIME — Approver Dashboard</title>

<style>
:root{
  --red:#c1121f;
  --redDark:#9b0f19;
  --ink:#0f172a;
  --muted:#64748b;
  --line:#e2e8f0;
  --soft:#f8fafc;
  --card:#ffffff;

  --good:#0f766e;
  --bad:#b42318;
  --warn:#b54708;

  --shadow: 0 18px 55px rgba(2,6,23,.10);
  --shadow2: 0 10px 24px rgba(2,6,23,.08);

  --radius:18px;
  --radius2:14px;
  --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
}

*{box-sizing:border-box}
body{
  margin:0;
  font-family:var(--font);
  background:
    radial-gradient(1000px 520px at 20% 0%, rgba(193,18,31,.08), transparent 55%),
    radial-gradient(900px 500px at 90% 10%, rgba(193,18,31,.06), transparent 55%),
    linear-gradient(180deg, #fff 0%, #fff 70%, #fafafa 100%);
  color:var(--ink);
}

.topbar{
  position:sticky; top:0; z-index:10;
  background: rgba(255,255,255,.92);
  backdrop-filter: blur(10px);
  border-bottom:1px solid var(--line);
}
.topbarInner{
  max-width:1200px;
  margin:auto;
  padding:14px 18px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
}
.brand{ display:flex; gap:12px; align-items:center; min-width:0; }
.brand img{ width:110px; max-height:54px; object-fit:contain; display:block; }
.brandText{ line-height:1.1; min-width:0; }
.brandText .inst{ font-size:14px; font-weight:900; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; color:#0f172a; }
.brandText .sys{ font-size:18px; font-weight:950; color:var(--red); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

.btn{
  border:none;
  border-radius:14px;
  padding:10px 14px;
  font-weight:950;
  cursor:pointer;
  color:#fff;
  background:linear-gradient(135deg,var(--red),var(--redDark));
  box-shadow: 0 12px 26px rgba(193,18,31,.20);
  transition:.15s ease;
}
.btn:hover{ transform: translateY(-1px); box-shadow: 0 16px 34px rgba(193,18,31,.25); }
.btn:active{ transform: translateY(0px) scale(.99); }
.btn:disabled{ opacity:.6; cursor:not-allowed; transform:none; box-shadow:none; }

.wrap{ max-width:1200px; margin:auto; padding:20px 18px 28px; }

.mainTabs{
  display:flex; gap:10px; flex-wrap:wrap; margin-bottom:14px;
}
.mainTab{
  border:1px solid var(--line);
  background:#fff;
  padding:10px 12px;
  border-radius:14px;
  cursor:pointer;
  font-weight:950;
  font-size:13px;
  color:#0f172a;
  transition:.15s ease;
  min-width:160px;
  text-align:center;
  box-shadow: 0 8px 18px rgba(2,6,23,.05);
}
.mainTab:hover{ border-color: rgba(193,18,31,.35); transform: translateY(-1px); }
.mainTab.active{
  border-color: rgba(193,18,31,.55);
  background: rgba(193,18,31,.06);
  color: var(--redDark);
  box-shadow: 0 14px 28px rgba(193,18,31,.10);
}

.panel{
  background:var(--card);
  border:1px solid var(--line);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  overflow:hidden;
}
.panelHead{
  padding:14px 16px 10px;
  border-bottom:1px solid var(--line);
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:10px;
}
.panelTitle{ margin:0; font-size:16px; font-weight:1000; }
.panelBody{ padding:14px 16px 16px; }
.hidden{ display:none !important; }

.headerGrid{
  display:grid;
  grid-template-columns: 340px 1fr;
  gap:14px;
  margin-bottom:14px;
  align-items: start;
}
@media(max-width: 900px){ .headerGrid{ grid-template-columns:1fr; } }

/* Profile */
.approverName{ font-size:18px; font-weight:1050; letter-spacing:.2px; }
.approverMeta{
  margin-top:8px;
  font-size:13px;
  color:#0f172a;
  font-weight:750;
  line-height:1.6;
}
.metaLine{
  padding:8px 10px;
  border-radius:14px;
  border:1px solid var(--line);
  background: rgba(15,23,42,.02);
  margin-top:8px;
}
.metaLine b{ color: var(--redDark); }

/* Filters / Dashboard */
.filterBar{
  display:grid;
  grid-template-columns: 1fr 1fr 140px;
  gap:10px;
  margin-bottom:12px;
}
@media(max-width: 980px){ .filterBar{ grid-template-columns:1fr 1fr; } }
.filterBox{
  border:1px solid var(--line);
  border-radius:16px;
  background:var(--soft);
  padding:10px 12px;
}
.filterBox label{
  display:block;
  font-size:11px;
  color:var(--muted);
  font-weight:900;
  letter-spacing:.2px;
  margin-bottom:6px;
}
select, input{
  width:100%;
  border:1px solid var(--line);
  border-radius:14px;
  padding:10px 10px;
  font-size:13px;
  font-weight:800;
  outline:none;
  background:#fff;
}
select:focus, input:focus{
  border-color: rgba(193,18,31,.55);
  box-shadow: 0 0 0 4px rgba(193,18,31,.12);
}
.applyBtn{
  height:42px;
  align-self:end;
  border:none;
  border-radius:14px;
  padding:0 14px;
  background: linear-gradient(135deg, var(--red), var(--redDark));
  color:#fff;
  font-weight:950;
  cursor:pointer;
  box-shadow: 0 12px 26px rgba(193,18,31,.18);
  transition:.15s ease;
}
.applyBtn:hover{ transform: translateY(-1px); box-shadow: 0 16px 34px rgba(193,18,31,.22); }
.applyBtn:disabled{ opacity:.6; cursor:not-allowed; transform:none; box-shadow:none; }

.metrics{ display:grid; grid-template-columns: repeat(5, 1fr); gap:10px; }
@media(max-width: 1050px){ .metrics{ grid-template-columns: repeat(2, 1fr); } }
.metric{
  border:1px solid var(--line);
  border-radius:16px;
  background:var(--soft);
  padding:12px;
  box-shadow: var(--shadow2);
}
.metric .k{ font-size:11px; color:var(--muted); font-weight:950; letter-spacing:.2px; }
.metric .v{ margin-top:6px; font-size:24px; font-weight:1100; }

/* Reports */
.reportsGrid{
  margin-top:14px;
  display:grid;
  grid-template-columns: 1fr;
  gap:14px;
}
.reportIntro{
  color:var(--muted);
  font-weight:800;
  font-size:12.5px;
  line-height:1.45;
}
.pills{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  margin:10px 0 12px;
}
.pill{
  border:1px solid var(--line);
  background:#fff;
  padding:10px 12px;
  border-radius:999px;
  cursor:pointer;
  font-weight:950;
  font-size:13px;
  transition:.15s ease;
  box-shadow: 0 10px 22px rgba(2,6,23,.06);
}
.pill:hover{ transform: translateY(-1px); border-color: rgba(193,18,31,.35); }
.pill.active{
  background: rgba(193,18,31,.08);
  border-color: rgba(193,18,31,.55);
  color: var(--redDark);
  box-shadow: 0 14px 28px rgba(193,18,31,.10);
}

.reportRow{
  display:grid;
  grid-template-columns: 1.2fr 1fr 1fr 1fr 170px;
  gap:10px;
}
@media(max-width: 1100px){ .reportRow{ grid-template-columns: 1fr 1fr; } }

.smallBtns{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
.btnGhost{
  border:1px solid var(--line);
  background:#fff;
  color:#0f172a;
  border-radius:14px;
  padding:10px 12px;
  font-weight:950;
  cursor:pointer;
  transition:.15s ease;
  box-shadow: 0 10px 22px rgba(2,6,23,.06);
}
.btnGhost:hover{ transform: translateY(-1px); border-color: rgba(193,18,31,.35); }

.toast{
  margin-top:12px;
  border-radius:14px;
  padding:10px 12px;
  border:1px solid var(--line);
  background:#fff;
  display:none;
  font-size:13px;
  line-height:1.45;
  font-weight:750;
}
.toast.show{ display:block; }
.toast.good{ border-color: rgba(15,118,110,.25); background: rgba(15,118,110,.06); color:#0f3d39; }
.toast.bad{ border-color: rgba(180,35,24,.22); background: rgba(180,35,24,.06); color:#5a1110; }

/* History Tabs */
.statusTabs{ display:flex; gap:10px; margin-bottom:12px; flex-wrap:wrap; }
.statusTab{
  padding:9px 12px;
  border-radius:999px;
  border:1px solid var(--line);
  background:#fff;
  font-weight:950;
  cursor:pointer;
  transition:.15s ease;
  display:flex; align-items:center; gap:8px;
  box-shadow: 0 10px 22px rgba(2,6,23,.06);
}
.statusTab:hover{ transform: translateY(-1px); border-color: rgba(193,18,31,.35); }
.statusTab.active{
  background:rgba(193,18,31,.08);
  border-color:rgba(193,18,31,.5);
  color:var(--redDark);
}
.count{
  border:1px solid var(--line);
  background:#fff;
  border-radius:999px;
  padding:3px 8px;
  font-size:12px;
  font-weight:950;
  min-width:30px;
  text-align:center;
}

/* Cards */
.requestCard{
  background:#fff;
  border:1px solid var(--line);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  padding:16px;
  margin-bottom:14px;
}
.cardTop{ display:flex; justify-content:space-between; align-items:flex-start; gap:10px; flex-wrap:wrap; }
.studentBlock{ display:flex; gap:12px; align-items:center; min-width:0; }

.studentPhoto{
  width:70px; height:92px;
  border-radius:18px;
  border:1px solid var(--line);
  background:var(--soft);
  object-fit:cover;
  display:block;
}
.studentAvatar{
  width:70px; height:92px;
  border-radius:18px;
  border:1px dashed rgba(193,18,31,.35);
  background: rgba(193,18,31,.05);
  display:grid;
  place-items:center;
  color:var(--redDark);
  font-weight:1100;
  letter-spacing:.5px;
  text-transform:uppercase;
}
.studentText{ min-width:0; }
.studentName{ font-size:18px; font-weight:1050; }
.studentMeta{ margin-top:4px; font-size:13.5px; color:var(--muted); font-weight:750; }

.reqCountLine{
  margin-top:8px;
  padding:8px 10px;
  border-radius:14px;
  background: rgba(193,18,31,.06);
  border: 1px dashed rgba(193,18,31,.35);
  color: var(--redDark);
  font-weight:900;
  font-size:13px;
}

.badge{
  padding:7px 12px;
  border-radius:999px;
  font-size:12px;
  font-weight:950;
  white-space:nowrap;
}
.pending{background:rgba(181,71,8,.08); color:var(--warn)}
.approved{background:rgba(15,118,110,.08); color:var(--good)}
.rejected{background:rgba(180,35,24,.08); color:var(--bad)}

.details{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:12px;
  margin-top:14px;
}
@media(max-width:700px){ .details{ grid-template-columns:1fr } }

.kv{
  background:var(--soft);
  border-radius:16px;
  padding:12px;
  border:1px solid var(--line);
}
.kv .k{ font-size:11px; color:var(--muted); font-weight:900; letter-spacing:.2px; }
.kv .v{ margin-top:6px; font-size:15px; font-weight:1000; letter-spacing:.1px; }
.reasonBox{ grid-column:1/-1; }

textarea{
  width:100%;
  margin-top:10px;
  padding:12px;
  border-radius:16px;
  border:1px solid var(--line);
  font-family:var(--font);
  font-size:14px;
  resize:vertical;
  min-height:86px;
  outline:none;
}
textarea:focus{
  border-color: rgba(193,18,31,.55);
  box-shadow: 0 0 0 4px rgba(193,18,31,.12);
}

.actions{ margin-top:12px; display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
.actionBtn{
  border:none;
  padding:11px 18px;
  border-radius:16px;
  font-weight:1050;
  cursor:pointer;
  transition: .15s ease;
  box-shadow: 0 12px 24px rgba(2,6,23,.14);
  letter-spacing:.2px;
  color:#fff;
}
.actionBtn:hover{ transform: translateY(-1px); box-shadow: 0 16px 34px rgba(2,6,23,.18); }
.actionBtn:active{ transform: translateY(0px) scale(.99); }
.actionBtn:disabled{ cursor:not-allowed; opacity:.55; transform:none; box-shadow:none; }

.approveBtn{ background: linear-gradient(135deg, var(--good), #14b8a6); }
.rejectBtn{ background: linear-gradient(135deg, var(--bad), #ff3b3b); }

.changeBtn{
  border:none;
  padding:10px 14px;
  border-radius:14px;
  font-weight:1000;
  cursor:pointer;
  transition:.15s ease;
  box-shadow: 0 10px 22px rgba(2,6,23,.10);
  color:#fff;
}
.changeBtn:hover{ transform: translateY(-1px); }
.changeApprove{ background: linear-gradient(135deg, var(--good), #14b8a6); }
.changeReject{ background: linear-gradient(135deg, var(--bad), #ff3b3b); }

.lockNote{
  margin-top:10px;
  padding:10px 12px;
  border-radius:14px;
  border:1px dashed rgba(180,35,24,.35);
  background: rgba(180,35,24,.05);
  color:#7a1512;
  font-weight:900;
  font-size:12.5px;
}

.inlineOpt{
  display:flex; align-items:center; gap:10px; flex-wrap:wrap;
  padding:10px 12px; border-radius:16px; border:1px dashed rgba(193,18,31,.3);
  background: rgba(193,18,31,.04);
  margin-top:10px;
  font-weight:900;
  color: var(--redDark);
}
.inlineOpt input{ width:auto; }
.smallNote{ font-size:12px; color:var(--muted); font-weight:850; margin-top:8px; line-height:1.4; }
</style>
</head>

<body>
<div class="topbar">
  <div class="topbarInner">
    <div class="brand">
      <img src="../assets/img/xime-logo.jpg" alt="XIME Logo">
      <div class="brandText">
        <div class="inst">Xavier Institute of Management and Entrepreneurship</div>
        <div class="sys">Leave Management System</div>
      </div>
    </div>
    <button class="btn" id="logoutBtn" type="button">Logout</button>
  </div>
</div>

<div class="wrap">
  <div class="mainTabs">
    <div class="mainTab active" id="tabDashboard" type="button">Dashboard</div>
    <div class="mainTab" id="tabRequests" type="button">Requests</div>
    <div class="mainTab" id="tabHistory" type="button">History</div>
  </div>

  <!-- DASHBOARD -->
  <section id="pageDashboard">
    <div class="headerGrid">

      <section class="panel">
        <div class="panelHead">
          <h3 class="panelTitle">My Profile</h3>
        </div>
        <div class="panelBody">
          <div class="approverName" id="apName">—</div>

          <div class="approverMeta">
            <div class="metaLine" id="lineEmail"><b>Email</b> — <span id="apEmail">—</span></div>
            <div class="metaLine" id="lineWarden" style="display:none;"><b>Warden</b> — <span id="apWarden">—</span></div>
            <div class="metaLine" id="lineBC" style="display:none;"><b>Batch Coordinator</b> — <span id="apBC">—</span></div>
            <div class="metaLine" id="lineDean" style="display:none;"><b>Dean</b> — <span id="apDean">Active</span></div>
          </div>
        </div>
      </section>

      <section class="panel">
        <div class="panelHead">
          <h3 class="panelTitle">Dashboard</h3>
        </div>
        <div class="panelBody">
          <div class="filterBar">
            <div class="filterBox">
              <label>From Date (Out)</label>
              <input id="fFrom" type="date">
            </div>
            <div class="filterBox">
              <label>To Date (Out)</label>
              <input id="fTo" type="date">
            </div>
            <button class="applyBtn" type="button" id="applyFilters">Apply</button>
          </div>

          <div class="metrics">
            <div class="metric"><div class="k">TOTAL (IN SCOPE)</div><div class="v" id="mTotal">0</div></div>
            <div class="metric"><div class="k">PENDING FOR ME</div><div class="v" id="mPending">0</div></div>
            <div class="metric"><div class="k">APPROVED BY ME</div><div class="v" id="mApproved">0</div></div>
            <div class="metric"><div class="k">REJECTED BY ME</div><div class="v" id="mRejected">0</div></div>
            <div class="metric"><div class="k">WEEKEND LEAVES (IN SCOPE)</div><div class="v" id="mWeekend">0</div></div>
          </div>
        </div>
      </section>

    </div>

    <!-- REPORTS -->
    <div class="reportsGrid">
      <section class="panel">
        <div class="panelHead">
          <h3 class="panelTitle">Reports (Download PDF)</h3>
          <div class="smallBtns">
            <button class="btnGhost" id="repClear" type="button">Clear</button>
          </div>
        </div>
        <div class="panelBody">
          <div class="reportIntro">
            Download PDF for <b>Final Approved</b> requests that were <b>approved by you</b> at your stage.
            Report shows <b>Arrival Status</b> (Blank if IN not crossed, Not yet reached if IN crossed but not verified,
            and Late/On time/Before time if verified).
          </div>

          <div class="pills">
            <button class="pill active" id="repModeTime" type="button">Timeframe (All Final Approved by Me)</button>
            <button class="pill" id="repModeStudent" type="button">Student-wise (Roll No + Timeframe)</button>
          </div>

          <div class="reportRow">
            <div class="filterBox" id="repRollBox" style="display:none;">
              <label>Student Roll No</label>
              <input id="repRoll" type="text" placeholder="e.g., C08001" />
            </div>

            <div class="filterBox">
              <label>From Date (IN)</label>
              <input id="repFrom" type="date" />
            </div>

            <div class="filterBox">
              <label>To Date (IN)</label>
              <input id="repTo" type="date" />
            </div>

            <div class="filterBox">
              <label>Year</label>
              <select id="repYear">
                <option value="all">All</option>
                <option value="1">Year 1</option>
                <option value="2">Year 2</option>
              </select>
            </div>

            <button class="applyBtn" id="repDownload" type="button">Download PDF</button>
          </div>

          <div class="pills" style="margin-top:10px;">
            <button class="pill" id="repPreset7" type="button">Last 7 Days</button>
            <button class="pill" id="repPreset30" type="button">Last 30 Days</button>
            <button class="pill" id="repPresetThisMonth" type="button">This Month</button>
          </div>

          <div id="repToast" class="toast"></div>
        </div>
      </section>
    </div>
  </section>

  <!-- REQUESTS (PENDING ONLY) -->
  <section id="pageRequests" class="hidden">
    <div id="reqFilterWrap" class="filterBar" style="grid-template-columns: 1fr 1fr 140px; margin-bottom:12px;">
      <div class="filterBox">
        <label>From Date (Out)</label>
        <input id="rFrom" type="date">
      </div>
      <div class="filterBox">
        <label>To Date (Out)</label>
        <input id="rTo" type="date">
      </div>
      <button class="applyBtn" type="button" id="applyReqFilters">Apply</button>
    </div>

    <div class="smallNote">
      This page shows only <b>pending requests assigned to you</b>.  
      Escalation to Dean can be selected while approving.
    </div>

    <div id="requestsContainer"></div>
  </section>

  <!-- HISTORY -->
  <section id="pageHistory" class="hidden">

    <div class="panel" style="margin-bottom:12px;">
      <div class="panelHead">
        <h3 class="panelTitle">Filters</h3>
        <div class="smallBtns">
          <button class="btnGhost" id="hClearFilters" type="button">Clear</button>
        </div>
      </div>
      <div class="panelBody">
        <div class="filterBar" style="grid-template-columns: 1fr 1fr 1fr; align-items:end;">
          <div class="filterBox">
            <label>From Date (Out)</label>
            <input id="hFrom" type="date">
          </div>
          <div class="filterBox">
            <label>To Date (Out)</label>
            <input id="hTo" type="date">
          </div>
          <div class="filterBox">
            <label>Roll No</label>
            <input id="hRoll" type="text" placeholder="e.g., C08001">
          </div>
        </div>

        <div class="filterBar" style="grid-template-columns: 1fr 1fr 1fr; margin-top:10px;">
          <div class="filterBox">
            <label>Year</label>
            <select id="hYear">
              <option value="all">All</option>
              <option value="1">Year 1</option>
              <option value="2">Year 2</option>
            </select>
          </div>
          <div class="filterBox">
            <label>Hostel</label>
            <select id="hHostel">
              <option value="all">All</option>
              <option value="boys">Boys</option>
              <option value="girls">Girls</option>
              <option value="guest_house">Guest House</option>
            </select>
          </div>
          <div class="filterBox">
            <label>Reason Category</label>
            <select id="hReason">
              <option value="all">All</option>
              <option value="weekend_leave">Weekend Leave</option>
              <option value="academic">Academic</option>
              <option value="emergency">Emergency</option>
              <option value="vacation">Vacation</option>
              <option value="other">Other</option>
              <option value="personal">Personal (legacy)</option>
            </select>
          </div>
        </div>

        <div class="filterBar" style="grid-template-columns: 1fr 1fr 140px; margin-top:10px;">
          <div class="filterBox">
            <label>Late Students Only</label>
            <select id="hLateOnly">
              <option value="no" selected>No</option>
              <option value="yes">Yes</option>
            </select>
          </div>
          <div class="filterBox">
            <label>Not Verified Only</label>
            <select id="hNotVerifiedOnly">
              <option value="no" selected>No</option>
              <option value="yes">Yes</option>
            </select>
          </div>
          <button class="applyBtn" id="hApplyFilters" type="button">Apply</button>
        </div>
      </div>
    </div>

    <div class="statusTabs">
      <div class="statusTab active" id="hApproved">Approved <span class="count" id="hcApproved">0</span></div>
      <div class="statusTab" id="hRejected">Rejected <span class="count" id="hcRejected">0</span></div>
      <div class="statusTab" id="hEscalated">Escalated to Dean <span class="count" id="hcEscalated">0</span></div>
      <div class="statusTab hidden" id="hIntimation">Intimation (Warden Approved) <span class="count" id="hcIntimation">0</span></div>
    </div>

    <div id="historyContainer"></div>
  </section>

</div>

<!-- PDF libs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
  import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
  import {
    getFirestore, doc, getDoc, collection, getDocs, query, where, updateDoc,
    serverTimestamp, setDoc, Timestamp
  } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

  window.addEventListener("pageshow", (e) => {
    if (e.persisted) window.location.reload();
  });

  const firebaseConfig = {
    apiKey: "AIzaSyDgoq2rMU5kiKcz_27-hjBzd8rxS8yQqdY",
    authDomain: "xime-leave-system-b25a4.firebaseapp.com",
    projectId: "xime-leave-system-b25a4",
    storageBucket: "xime-leave-system-b25a4.firebasestorage.app",
    messagingSenderId: "802112635142",
    appId: "1:802112635142:web:0fd0f5ad1ae3ef8eb4de87"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  // ===== DOM =====
  const logoutBtn = document.getElementById("logoutBtn");
  const tabDashboard = document.getElementById("tabDashboard");
  const tabRequests  = document.getElementById("tabRequests");
  const tabHistory   = document.getElementById("tabHistory");

  const pageDashboard = document.getElementById("pageDashboard");
  const pageRequests  = document.getElementById("pageRequests");
  const pageHistory   = document.getElementById("pageHistory");

  // Profile nodes
  const apName = document.getElementById("apName");
  const apEmail = document.getElementById("apEmail");
  const lineWarden = document.getElementById("lineWarden");
  const apWarden = document.getElementById("apWarden");
  const lineBC = document.getElementById("lineBC");
  const apBC = document.getElementById("apBC");
  const lineDean = document.getElementById("lineDean");
  const apDean = document.getElementById("apDean");

  // Dashboard filters
  const fFrom = document.getElementById("fFrom");
  const fTo   = document.getElementById("fTo");
  const applyFilters = document.getElementById("applyFilters");

  // Metrics
  const mTotal = document.getElementById("mTotal");
  const mPending = document.getElementById("mPending");
  const mApproved = document.getElementById("mApproved");
  const mRejected = document.getElementById("mRejected");
  const mWeekend = document.getElementById("mWeekend");

  // Requests filter
  const rFrom = document.getElementById("rFrom");
  const rTo = document.getElementById("rTo");
  const applyReqFilters = document.getElementById("applyReqFilters");

  const requestsContainer = document.getElementById("requestsContainer");
  const historyContainer = document.getElementById("historyContainer");

  // History tabs
  const hApproved = document.getElementById("hApproved");
  const hRejected = document.getElementById("hRejected");
  const hEscalated = document.getElementById("hEscalated");
  const hIntimation = document.getElementById("hIntimation");
  const hcApproved = document.getElementById("hcApproved");
  const hcRejected = document.getElementById("hcRejected");
  const hcEscalated = document.getElementById("hcEscalated");
  const hcIntimation = document.getElementById("hcIntimation");

  // History filters
  const hFrom = document.getElementById("hFrom");
  const hTo = document.getElementById("hTo");
  const hRoll = document.getElementById("hRoll");
  const hYear = document.getElementById("hYear");
  const hHostel = document.getElementById("hHostel");
  const hReason = document.getElementById("hReason");
  const hLateOnly = document.getElementById("hLateOnly");
  const hNotVerifiedOnly = document.getElementById("hNotVerifiedOnly");
  const hApplyFilters = document.getElementById("hApplyFilters");
  const hClearFilters = document.getElementById("hClearFilters");

  // Reports DOM
  const repModeTime = document.getElementById("repModeTime");
  const repModeStudent = document.getElementById("repModeStudent");
  const repRollBox = document.getElementById("repRollBox");
  const repRoll = document.getElementById("repRoll");
  const repFrom = document.getElementById("repFrom");
  const repTo = document.getElementById("repTo");
  const repYear = document.getElementById("repYear");
  const repDownload = document.getElementById("repDownload");
  const repToast = document.getElementById("repToast");
  const repClear = document.getElementById("repClear");
  const repPreset7 = document.getElementById("repPreset7");
  const repPreset30 = document.getElementById("repPreset30");
  const repPresetThisMonth = document.getElementById("repPresetThisMonth");

  // ===== State =====
  let repMode = "time"; // time | student

  let currentUserEmailRaw = "";
  let currentUserEmailLower = "";
  let roleDoc = null;
  let roleType = "approver"; // approver | dean

  let canBC = false;
  let canWarden = false;
  let canDean = false;
  let bcYears = []; // from role doc

  let dashFrom = "";
  let dashTo = "";
  let reqFrom = "";
  let reqTo = "";

  let activeHistoryTab = "approved"; // approved | rejected | escalated | intimation

  let cacheAllForApprover = []; // pending + acted by me + escalated
  let cacheIntimationForBC = []; // warden-approved final requests for my bc year(s)
  const rosterPhotoCache = new Map();
  const IMG_PLACEHOLDER = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";

  // ===== Helpers =====
  function isoNow(){ return new Date().toISOString(); }
  function normalizeEmail(v){ return String(v || "").trim().toLowerCase(); }
  function normalizeRollno(v){ return String(v || "").trim().toUpperCase(); }

  const YEAR_TO_BATCH = { "1":"Batch 9", "2":"Batch 8" };

  function showPage(which){
    [tabDashboard, tabRequests, tabHistory].forEach(x => x.classList.remove("active"));
    [pageDashboard, pageRequests, pageHistory].forEach(x => x.classList.add("hidden"));

    if(which === "dashboard"){
      tabDashboard.classList.add("active");
      pageDashboard.classList.remove("hidden");
    } else if (which === "requests") {
      tabRequests.classList.add("active");
      pageRequests.classList.remove("hidden");
    } else {
      tabHistory.classList.add("active");
      pageHistory.classList.remove("hidden");
    }
  }

  function parseDateStart(dateStr){
    if (!dateStr) return null;
    const d = new Date(`${dateStr}T00:00:00`);
    return isNaN(d) ? null : d;
  }
  function parseDateEnd(dateStr){
    if (!dateStr) return null;
    const d = new Date(`${dateStr}T23:59:59.999`);
    return isNaN(d) ? null : d;
  }
  function dateRangeToTimestamps(fromDate, toDate){
    const s = parseDateStart(fromDate);
    const e = parseDateEnd(toDate);
    if (!s || !e) return { start:null, end:null };
    return { start: Timestamp.fromDate(s), end: Timestamp.fromDate(e) };
  }

  function getOutDT(row){ return row.out_datetime || row.outDT || row.outDateTime || ""; }
  function getInDT(row){ return row.in_datetime || row.inDT || row.inDateTime || ""; }

  function toJSDate(val){
    if (!val) return null;
    if (val instanceof Date) return val;
    if (typeof val?.toDate === "function") return val.toDate(); // Timestamp
    const d = new Date(val);
    return isNaN(d) ? null : d;
  }

  function isBeforeOutTime(row){
    const outVal = getOutDT(row);
    const outD = toJSDate(outVal);
    if (!outD) return false;
    return new Date() < outD;
  }

  function isEscalatedLocked(row){
    const st = String(row?.status || "").toLowerCase();
    if (st === "pending_dean") return true;
    if (!!row?.escalation?.requested) return true;
    return false;
  }

  function getCurrentHolderEmail(row){
    return String(row?.current?.holder_email || row?.current_holder_email || row?.currentHolderEmail || row?.current_holder || "").trim();
  }
  function getCurrentHolderRole(row){
    return String(row?.current?.holder_role || row?.current_holder_role || row?.currentRole || "").trim();
  }

  function inDateRangeOutDT(row, fromDate, toDate){
    const outVal = getOutDT(row);
    if (!outVal) return false;
    const outDate = toJSDate(outVal);
    if (!outDate) return false;

    const s = parseDateStart(fromDate);
    const e = parseDateEnd(toDate);
    if (s && outDate < s) return false;
    if (e && outDate > e) return false;
    return true;
  }

  function fmtDT(val){
    const dt = toJSDate(val);
    if (!dt) return "-";
    const dd = String(dt.getDate()).padStart(2,"0");
    const mm = String(dt.getMonth()+1).padStart(2,"0");
    const yyyy = dt.getFullYear();
    let hh = dt.getHours();
    const min = String(dt.getMinutes()).padStart(2,"0");
    const ampm = hh >= 12 ? "PM" : "AM";
    hh = hh % 12; hh = hh ? hh : 12;
    hh = String(hh).padStart(2,"0");
    return `${dd}/${mm}/${yyyy} ${hh}:${min} ${ampm}`;
  }

  function initials(name){
    const n = String(name || "").trim();
    if (!n) return "ST";
    const parts = n.split(/\s+/).filter(Boolean);
    const a = parts[0]?.[0] || "S";
    const b = parts.length > 1 ? (parts[parts.length-1]?.[0] || "") : (parts[0]?.[1] || "");
    return (a + b).toUpperCase();
  }

  function formatLateMinutes(mins){
    const m = Math.max(0, Number(mins) || 0);
    const h = Math.floor(m / 60);
    const r = m % 60;
    if (h <= 0) return `${r}m`;
    if (r === 0) return `${h}h`;
    return `${h}h ${r}m`;
  }

  // --- Arrival Status helpers for PDF ---
  function minutesToHM(mins){
    const m = Math.max(0, Math.floor(Number(mins) || 0));
    const h = Math.floor(m / 60);
    const r = m % 60;
    if (h <= 0) return `${r}m`;
    if (r === 0) return `${h}h`;
    return `${h}h ${r}m`;
  }

  function getArrivalStatusText(row){
    const plannedInVal = getInDT(row);
    const plannedIn = toJSDate(plannedInVal);
    if (!plannedIn) return "";

    const now = new Date();
    if (now < plannedIn) return "";

    const arrival = row.arrival || {};
    const verified = !!arrival.verified;

    if (!verified) return "Not yet reached";

    const actualVal =
      arrival.actual_in_time ||
      arrival.actual_in_datetime ||
      arrival.verified_at ||
      arrival.verifiedAt ||
      null;

    const actualIn = toJSDate(actualVal);
    if (!actualIn) return "Reached";

    const diffMins = Math.round((actualIn.getTime() - plannedIn.getTime()) / 60000);

    if (diffMins > 0) return `Late by ${minutesToHM(diffMins)}`;
    if (diffMins === 0) return "On time";
    return `Before time by ${minutesToHM(Math.abs(diffMins))}`;
  }

  function isFinalApprovedStatus(st){
    const s = String(st || "").toLowerCase();
    return s === "approved_final" || s === "approved_dean_final";
  }

  function didIAct(chain){
    const entry = chainEntryForMe(chain);
    if (!entry) return null;
    const st = String(entry.action || entry.status || "").toLowerCase();
    if (st === "approved") return "approved";
    if (st === "rejected") return "rejected";
    return null;
  }

  function chainEntryForMe(chain){
    const meLower = currentUserEmailLower;
    const meRaw = currentUserEmailRaw;
    const arr = Array.isArray(chain) ? chain : [];
    return arr.find(x => {
      const e = String(x?.email || "").trim();
      return e === meRaw || e.toLowerCase() === meLower;
    }) || null;
  }

  function isPendingForMe(row){
    const holder = getCurrentHolderEmail(row);
    const holderOk = holder === currentUserEmailRaw || holder.toLowerCase() === currentUserEmailLower;
    const st = String(row.status || "").toLowerCase();
    return holderOk && (st === "pending_l1" || st === "pending_dean");
  }

  function getStudentYear(row){
    return String(row.student_year ?? row.studentYear ?? "").trim();
  }
  function getHostel(row){
    return String(row.student_hostel || "").trim().toLowerCase();
  }
  function getReasonCat(row){
    return String(row.reason_category || row.reasonCategory || "").trim().toLowerCase();
  }

  function computeArrivalStatusLine(row){
    const arrival = row.arrival || {};
    const verified = !!arrival.verified;
    const lateMinutes = arrival.late_minutes ?? arrival.lateMinutes;

    if (isFinalApprovedStatus(row.status)){
      if (!verified){
        return "⚠️ Arrival: NOT VERIFIED (Student has not entered / not verified)";
      }
      const verifiedAt = arrival.verified_at || arrival.verifiedAt || arrival.actual_in_time || arrival.actualInTime || null;
      const atTxt = verifiedAt ? fmtDT(verifiedAt) : "—";
      const lateTxt = (lateMinutes != null && Number(lateMinutes) > 0)
        ? `Late by ${formatLateMinutes(lateMinutes)}`
        : "On time";
      return `✅ Arrival: VERIFIED • ${lateTxt} • at ${atTxt}`;
    }

    if (verified){
      const lateTxt = (lateMinutes != null && Number(lateMinutes) > 0)
        ? `Late by ${formatLateMinutes(lateMinutes)}`
        : "On time";
      return `✅ Arrival: VERIFIED • ${lateTxt}`;
    }
    return "";
  }

  function isLateRow(row){
    const arrival = row.arrival || {};
    const verified = !!arrival.verified;
    const lateMinutes = arrival.late_minutes ?? arrival.lateMinutes ?? 0;
    return verified && Number(lateMinutes) > 0;
  }

  function isNotVerifiedRow(row){
    const arrival = row.arrival || {};
    const verified = !!arrival.verified;
    return !verified;
  }

  function isWeekendReason(row){
    const rc = getReasonCat(row);
    if (rc === "weekend_leave") return true;
    if (rc === "weekend" || rc === "weekend leave") return true;
    return false;
  }

  function computeCapabilitiesFromRoleDoc(d){
    bcYears = Array.isArray(d?.bc_years) ? d.bc_years.map(x => String(x)) : [];
    const wardenHostels = Array.isArray(d?.warden_hostels) ? d.warden_hostels.map(x => String(x).toLowerCase()) : [];
    canBC = bcYears.some(y => y === "1" || y === "2");
    canWarden = wardenHostels.length > 0;
    canDean = (roleType === "dean");
    return { bcYears, wardenHostels };
  }

  function updateApproverUI(){
    const name = String(roleDoc?.name || "").trim() || (canDean ? "Dean" : "Approver");
    apName.textContent = name;
    apEmail.textContent = currentUserEmailRaw;

    const { bcYears, wardenHostels } = computeCapabilitiesFromRoleDoc(roleDoc);

    if (canDean){
      lineDean.style.display = "block";
      apDean.textContent = "Active";
    } else {
      lineDean.style.display = "none";
    }

    if (wardenHostels.length){
      lineWarden.style.display = "block";
      const pretty = wardenHostels.map(h => {
        if (h === "boys") return "Boys Hostel";
        if (h === "girls") return "Girls Hostel";
        if (h === "guest_house" || h === "guesthouse") return "Guest House";
        return h;
      }).join(", ");
      apWarden.textContent = pretty;
    } else {
      lineWarden.style.display = "none";
    }

    if (bcYears.some(y => y === "1" || y === "2")){
      lineBC.style.display = "block";
      const batches = bcYears
        .filter(y => y === "1" || y === "2")
        .map(y => ({ "1":"Batch 9", "2":"Batch 8" }[y] || `Year ${y}`))
        .join(", ");
      apBC.textContent = batches;
    } else {
      lineBC.style.display = "none";
    }

    if (canBC){
      hIntimation.classList.remove("hidden");
    } else {
      hIntimation.classList.add("hidden");
    }
  }

  async function loadRoleDoc(){
    const refAdminLower = doc(db, "admins", currentUserEmailLower);
    const snapAdminLower = await getDoc(refAdminLower);
    if (snapAdminLower.exists()){
      roleType = "dean";
      return snapAdminLower.data();
    }

    const refAdminRaw = doc(db, "admins", currentUserEmailRaw);
    const snapAdminRaw = await getDoc(refAdminRaw);
    if (snapAdminRaw.exists()){
      roleType = "dean";
      return snapAdminRaw.data();
    }

    const refLower = doc(db, "approvers", currentUserEmailLower);
    const snapLower = await getDoc(refLower);
    if (snapLower.exists()){
      roleType = "approver";
      return snapLower.data();
    }

    const refRaw = doc(db, "approvers", currentUserEmailRaw);
    const snapRaw = await getDoc(refRaw);
    if (snapRaw.exists()){
      roleType = "approver";
      return snapRaw.data();
    }

    throw new Error("Access denied. You are not assigned as Batch Coordinator / Warden / Dean.");
  }

  async function tryGetDocs(qLower, qRaw){
    try{
      const snap = await getDocs(qLower);
      return snap.docs.map(d => ({ id: d.id, ...d.data() }));
    }catch(e){
      const snap2 = await getDocs(qRaw);
      return snap2.docs.map(d => ({ id: d.id, ...d.data() }));
    }
  }

  // ===== Photo helpers =====
  function extractDriveId(url){
    const u = String(url || "").trim();
    if (!u) return "";
    const m1 = u.match(/drive\.google\.com\/file\/d\/([^\/]+)\//);
    if (m1 && m1[1]) return m1[1];
    const m2 = u.match(/[?&]id=([^&]+)/);
    if (m2 && m2[1]) return m2[1];
    const m3 = u.match(/uc\?export=view&id=([^&]+)/);
    if (m3 && m3[1]) return m3[1];
    return "";
  }
  function resolveDriveUrls(rawLink){
    const id = extractDriveId(rawLink);
    if (!id) return { primary: rawLink, fallback: "" };
    const primary = `https://lh3.googleusercontent.com/d/${id}=w1000`;
    const fallback = `https://drive.google.com/uc?export=view&id=${id}`;
    return { primary, fallback };
  }

  function resolvePhotoURL(obj){
    const raw =
      obj?.photo_url ||
      obj?.photoUrl ||
      obj?.photoURL ||
      obj?.photo ||
      obj?.photoLink ||
      obj?.imageUrl ||
      obj?.imageURL ||
      obj?.student_photo_url ||
      "";

    const link = String(raw || "").trim();
    if (!link) return { primary:"", fallback:"" };

    if (link.includes("drive.google.com") || link.includes("googleusercontent.com")){
      return resolveDriveUrls(link);
    }
    if (link.startsWith("http://") || link.startsWith("https://")){
      return { primary: link, fallback: "" };
    }
    return { primary:"", fallback:"" };
  }

  async function getRosterPhotoResolved(rollno){
    const roll = normalizeRollno(rollno);
    if (!roll) return { primary:"", fallback:"" };
    if (rosterPhotoCache.has(roll)) return rosterPhotoCache.get(roll);

    try{
      const snap = await getDoc(doc(db, "students_roster", roll));
      if (!snap.exists()){
        const empty = { primary:"", fallback:"" };
        rosterPhotoCache.set(roll, empty);
        return empty;
      }
      const resolved = resolvePhotoURL(snap.data());
      rosterPhotoCache.set(roll, resolved);
      return resolved;
    }catch(e){
      const empty = { primary:"", fallback:"" };
      rosterPhotoCache.set(roll, empty);
      return empty;
    }
  }

  async function hydrateStudentPhoto(cardEl, rollno, studentName, requestRow){
    const img = cardEl.querySelector("img.studentPhoto");
    const av = cardEl.querySelector(".studentAvatar");
    if (!img || !av) return;

    av.textContent = initials(studentName);
    av.style.display = "grid";
    img.style.display = "none";

    let resolved = await getRosterPhotoResolved(rollno);
    if (!resolved?.primary){
      resolved = resolvePhotoURL(requestRow || {});
    }
    const { primary, fallback } = resolved || {};
    if (!primary) return;

    let usedFallback = false;

    img.onload = () => { img.style.display = "block"; av.style.display = "none"; };
    img.onerror = () => {
      if (!usedFallback && fallback){ usedFallback = true; img.src = fallback; return; }
      img.style.display = "none"; av.style.display = "grid";
    };

    img.src = primary;
  }

  // ===== Cache refresh =====
  async function refreshCache(){
    const meLower = currentUserEmailLower;
    const meRaw = currentUserEmailRaw;

    const qHoldLower = query(collection(db, "leave_requests"), where("current_holder_email", "==", meLower));
    const qHoldRaw   = query(collection(db, "leave_requests"), where("current_holder_email", "==", meRaw));

    const assignedAll = await tryGetDocs(qHoldLower, qHoldRaw);
    const pendingRows = assignedAll.filter(r => {
      const st = String(r.status || "").toLowerCase();
      return st === "pending_l1" || st === "pending_dean";
    });

    const qMineLower = query(collection(db, "leave_requests"), where("approver_emails", "array-contains", meLower));
    const qMineRaw   = query(collection(db, "leave_requests"), where("approver_emails", "array-contains", meRaw));

    let mineAll = [];
    try { mineAll = await tryGetDocs(qMineLower, qMineRaw); }
    catch(e){ mineAll = []; }

    const actedOrEscalated = mineAll.filter(r => {
      const acted = didIAct(r.approver_chain);
      if (acted) return true;
      if (r?.escalation?.requested) return true;
      return false;
    });

    const map = new Map();
    [...pendingRows, ...actedOrEscalated].forEach(r => map.set(r.id, r));
    cacheAllForApprover = [...map.values()];

    cacheIntimationForBC = [];
    if (canBC && bcYears.length){
      const years = bcYears.filter(y => y === "1" || y === "2");
      try{
        const qFinal = query(
          collection(db, "leave_requests"),
          where("status", "in", ["approved_final","approved_dean_final"])
        );
        const snap = await getDocs(qFinal);
        let rows = snap.docs.map(d => ({ id: d.id, ...d.data() }));

        rows = rows.filter(r => String(r?.routing?.l1_role || "").toLowerCase() === "warden");
        rows = rows.filter(r => years.includes(String(getStudentYear(r))));
        rows = rows.filter(r => inDateRangeOutDT(r, dashFrom, dashTo));

        rows.sort((a,b) => {
          const ad = toJSDate(getOutDT(a));
          const bd = toJSDate(getOutDT(b));
          return (bd?.getTime?.()||0) - (ad?.getTime?.()||0);
        });

        cacheIntimationForBC = rows;
      }catch(e){
        cacheIntimationForBC = [];
      }
    }
  }

  function computeDashboardMetrics(){
    const rows = cacheAllForApprover.filter(r => inDateRangeOutDT(r, dashFrom, dashTo));

    const total = rows.length;
    const pending = rows.filter(r => isPendingForMe(r)).length;
    const approved = rows.filter(r => didIAct(r.approver_chain) === "approved").length;
    const rejected = rows.filter(r => didIAct(r.approver_chain) === "rejected").length;

    const weekend = rows.filter(r => isWeekendReason(r)).length;

    mTotal.textContent = String(total);
    mPending.textContent = String(pending);
    mApproved.textContent = String(approved);
    mRejected.textContent = String(rejected);
    mWeekend.textContent = String(weekend);
  }

  // ===== Render Pending Requests =====
  function renderPendingRequests(){
    const rows = cacheAllForApprover
      .filter(r => isPendingForMe(r))
      .filter(r => inDateRangeOutDT(r, reqFrom, reqTo));

    rows.sort((a,b) => (toJSDate(getOutDT(b))?.getTime()||0) - (toJSDate(getOutDT(a))?.getTime()||0));

    requestsContainer.innerHTML = "";

    if (!rows.length){
      const empty = document.createElement("div");
      empty.style.padding = "14px";
      empty.style.color = "#64748b";
      empty.style.fontWeight = "850";
      empty.textContent = "No pending requests assigned to you.";
      requestsContainer.appendChild(empty);
      return;
    }

    rows.forEach(r => {
      const st = String(r.status || "").toLowerCase();
      const badgeClass = (st.includes("pending")) ? "pending" : (st.includes("approved") ? "approved" : "rejected");

      const studentName = r.student_name || "—";
      const roll = normalizeRollno(r.student_rollno || "");
      const room = r.student_room_no || "—";

      const reasonCat = String(r.reason_category || r.reasonCategory || "—").trim();
      const reasonTxt = String(r.reason_text || r.reasonText || r.reason || "").trim();
      const reasonLine = reasonTxt ? `${reasonCat} — ${reasonTxt}` : reasonCat;

      const outVal = getOutDT(r);
      const inVal  = getInDT(r);

      const arrivalLine = computeArrivalStatusLine(r);

      const holderRole = getCurrentHolderRole(r).toLowerCase();

      // ONLY Batch Coordinator can escalate (warden cannot)
      const canEscalate = (holderRole === "batch_coordinator") && !!(r.routing && r.routing.dean_email);

      const remarkId = `remark_${r.id}`;
      const escId = `esc_${r.id}`;

      const card = document.createElement("section");
      card.className = "requestCard";
      card.innerHTML = `
        <div class="cardTop">
          <div class="studentBlock">
            <img class="studentPhoto" src="${IMG_PLACEHOLDER}" alt="Student photo" style="display:none;">
            <div class="studentAvatar">${initials(studentName)}</div>
            <div class="studentText">
              <div class="studentName">${studentName}</div>
              <div class="studentMeta">${(roll||"—")} • Room ${room}</div>
              ${arrivalLine ? `<div class="reqCountLine">${arrivalLine}</div>` : ``}
            </div>
          </div>
          <div class="badge ${badgeClass}">${st.toUpperCase()}</div>
        </div>

        <div class="details">
          <div class="kv"><div class="k">OUT DATE & TIME</div><div class="v">${fmtDT(outVal)}</div></div>
          <div class="kv"><div class="k">IN DATE & TIME</div><div class="v">${fmtDT(inVal)}</div></div>
          <div class="kv reasonBox"><div class="k">REASON</div><div class="v">${reasonLine || "-"}</div></div>
        </div>

        <textarea id="${remarkId}" placeholder="Remark (optional)"></textarea>

        ${canEscalate ? `
          <label class="inlineOpt">
            <input type="checkbox" id="${escId}">
            Escalate to Dean after my approval
          </label>
        ` : ``}

        <div class="actions">
          <button class="actionBtn approveBtn" data-id="${r.id}" type="button">Approve</button>
          <button class="actionBtn rejectBtn" data-id="${r.id}" type="button">Reject</button>
        </div>
      `;

      requestsContainer.appendChild(card);
      hydrateStudentPhoto(card, roll, studentName, r);
    });

    requestsContainer.querySelectorAll(".approveBtn").forEach(btn => {
      btn.addEventListener("click", () => handleApprove(btn.dataset.id));
    });
    requestsContainer.querySelectorAll(".rejectBtn").forEach(btn => {
      btn.addEventListener("click", () => handleReject(btn.dataset.id));
    });
  }

  // ===== History filters apply =====
  function getHistoryFilters(){
    return {
      from: (hFrom.value || "").trim(),
      to: (hTo.value || "").trim(),
      roll: normalizeRollno(hRoll.value || ""),
      year: String(hYear.value || "all"),
      hostel: String(hHostel.value || "all").toLowerCase(),
      reason: String(hReason.value || "all").toLowerCase(),
      lateOnly: String(hLateOnly.value || "no") === "yes",
      notVerifiedOnly: String(hNotVerifiedOnly.value || "no") === "yes"
    };
  }

  function applyHistoryFilters(rows){
    const f = getHistoryFilters();

    rows = rows.filter(r => inDateRangeOutDT(r, f.from, f.to));

    if (f.roll){
      rows = rows.filter(r => normalizeRollno(r.student_rollno || "") === f.roll);
    }
    if (f.year !== "all"){
      rows = rows.filter(r => String(getStudentYear(r)) === String(f.year));
    }
    if (f.hostel !== "all"){
      rows = rows.filter(r => getHostel(r) === f.hostel);
    }
    if (f.reason !== "all"){
      rows = rows.filter(r => getReasonCat(r) === f.reason);
    }
    if (f.lateOnly){
      rows = rows.filter(r => isLateRow(r));
    }
    if (f.notVerifiedOnly){
      rows = rows.filter(r => isNotVerifiedRow(r) && isFinalApprovedStatus(r.status));
    }
    return rows;
  }

  // ===== History Render =====
  function setHistoryTab(which){
    activeHistoryTab = which;
    [hApproved, hRejected, hEscalated, hIntimation].forEach(x => x.classList.remove("active"));
    if (which === "approved") hApproved.classList.add("active");
    if (which === "rejected") hRejected.classList.add("active");
    if (which === "escalated") hEscalated.classList.add("active");
    if (which === "intimation") hIntimation.classList.add("active");
    renderHistory();
  }

  function canChangeMyDecision(row){
    // Must be something I acted on, must be BEFORE OUT time, and MUST NOT be escalated
    const myAct = didIAct(row.approver_chain);
    if (!myAct) return false;
    if (!isBeforeOutTime(row)) return false;
    if (isEscalatedLocked(row)) return false;
    return true;
  }

  function renderHistory(){
    let rows = [];

    if (activeHistoryTab === "intimation"){
      rows = cacheIntimationForBC.slice();
    } else {
      rows = cacheAllForApprover.slice();
      if (activeHistoryTab === "approved"){
        rows = rows.filter(r => didIAct(r.approver_chain) === "approved");
      } else if (activeHistoryTab === "rejected"){
        rows = rows.filter(r => didIAct(r.approver_chain) === "rejected");
      } else {
        rows = rows.filter(r => !!(r?.escalation?.requested));
      }
    }

    rows = applyHistoryFilters(rows);

    rows.sort((a,b) => (toJSDate(getOutDT(b))?.getTime()||0) - (toJSDate(getOutDT(a))?.getTime()||0));

    updateHistoryCounts();
    historyContainer.innerHTML = "";

    if (!rows.length){
      const empty = document.createElement("div");
      empty.style.padding = "14px";
      empty.style.color = "#64748b";
      empty.style.fontWeight = "850";
      empty.textContent = "No records found.";
      historyContainer.appendChild(empty);
      return;
    }

    for (const r of rows){
      const st = String(r.status || "").toLowerCase();
      const badgeClass =
        st.includes("pending") ? "pending" :
        st.includes("approved") ? "approved" :
        st.includes("rejected") ? "rejected" : "pending";

      const studentName = r.student_name || "—";
      const roll = normalizeRollno(r.student_rollno || "");
      const room = r.student_room_no || "—";

      const reasonCat = String(r.reason_category || "—").trim();
      const reasonTxt = String(r.reason_text || r.reason || "").trim();
      const reasonLine = reasonTxt ? `${reasonCat} — ${reasonTxt}` : reasonCat;

      const outVal = getOutDT(r);
      const inVal  = getInDT(r);

      const arrivalLine = computeArrivalStatusLine(r);

      const allowChange = canChangeMyDecision(r);
      const myAction = didIAct(r.approver_chain); // approved / rejected
      const changeRemarkId = `chg_remark_${r.id}`;

      const card = document.createElement("section");
      card.className = "requestCard";
      card.innerHTML = `
        <div class="cardTop">
          <div class="studentBlock">
            <img class="studentPhoto" src="${IMG_PLACEHOLDER}" alt="Student photo" style="display:none;">
            <div class="studentAvatar">${initials(studentName)}</div>
            <div class="studentText">
              <div class="studentName">${studentName}</div>
              <div class="studentMeta">${(roll||"—")} • Room ${room}</div>
              ${arrivalLine ? `<div class="reqCountLine">${arrivalLine}</div>` : ``}
            </div>
          </div>
          <div class="badge ${badgeClass}">${st.toUpperCase()}</div>
        </div>

        <div class="details">
          <div class="kv"><div class="k">OUT DATE & TIME</div><div class="v">${fmtDT(outVal)}</div></div>
          <div class="kv"><div class="k">IN DATE & TIME</div><div class="v">${fmtDT(inVal)}</div></div>
          <div class="kv reasonBox"><div class="k">REASON</div><div class="v">${reasonLine || "-"}</div></div>
        </div>

        ${
          allowChange ? `
            <textarea id="${changeRemarkId}" placeholder="Remark for change (optional)"></textarea>
            <div class="actions">
              ${myAction !== "approved" ? `<button class="changeBtn changeApprove" data-id="${r.id}" data-action="approved" type="button">Change to APPROVE</button>` : ``}
              ${myAction !== "rejected" ? `<button class="changeBtn changeReject" data-id="${r.id}" data-action="rejected" type="button">Change to REJECT</button>` : ``}
            </div>
            <div class="smallNote">Allowed only until OUT time. Once escalated to Dean, it becomes locked.</div>
          ` : (isEscalatedLocked(r) ? `<div class="lockNote">Locked: Escalated to Dean / pending Dean. No changes allowed.</div>` : ``)
        }
      `;
      historyContainer.appendChild(card);
      hydrateStudentPhoto(card, roll, studentName, r);
    }

    // Wire change buttons
    historyContainer.querySelectorAll(".changeBtn").forEach(btn => {
      btn.addEventListener("click", async () => {
        const id = btn.dataset.id;
        const action = btn.dataset.action; // approved/rejected
        await handleChangeDecision(id, action);
      });
    });
  }

  function updateHistoryCounts(){
    hcApproved.textContent = String(cacheAllForApprover.filter(r => didIAct(r.approver_chain) === "approved").length);
    hcRejected.textContent = String(cacheAllForApprover.filter(r => didIAct(r.approver_chain) === "rejected").length);
    hcEscalated.textContent = String(cacheAllForApprover.filter(r => !!(r?.escalation?.requested)).length);
    hcIntimation.textContent = String(cacheIntimationForBC.length);
  }

  // ===== Gatepass Public =====
  async function upsertPublicGatepass(requestId, requestRow){
    const outVal = getOutDT(requestRow);
    const inVal = getInDT(requestRow);

    const payload = {
      status: "approved",
      approved_public_at: isoNow(),
      student_name: requestRow.student_name || "",
      student_rollno: requestRow.student_rollno || "",
      student_room_no: requestRow.student_room_no || "",
      student_email: requestRow.student_email || "",
      student_uid: requestRow.student_uid || "",
      out_datetime: outVal || "",
      in_datetime: inVal || "",
      reason_category: requestRow.reason_category || "",
      reason_text: requestRow.reason_text || requestRow.reason || "",
      contact_no: requestRow.contact_no || "",
      photo_url: requestRow.student_photo_url || requestRow.photo_url || "",
      updatedAt: serverTimestamp(),
      updated_at: serverTimestamp()
    };

    await setDoc(doc(db, "gatepass_public", requestId), payload, { merge: true });
  }

  async function revokePublicGatepass(requestId, reason="decision_changed"){
    // We keep document (no delete) but mark invalid
    const payload = {
      status: "revoked",
      revoked_at: serverTimestamp(),
      revokedAt: serverTimestamp(),
      revoked_by: currentUserEmailLower,
      revoke_reason: String(reason || "decision_changed"),
      updatedAt: serverTimestamp(),
      updated_at: serverTimestamp()
    };
    try{
      await setDoc(doc(db, "gatepass_public", requestId), payload, { merge: true });
    }catch(e){
      // If rules disallow, ignore silently (but ideally allow it)
      console.warn("Unable to revoke gatepass_public:", e);
    }
  }

  // ===== Approve / Reject helpers =====
  function ensureDeanStage(chain, deanEmail){
    const arr = Array.isArray(chain) ? [...chain] : [];
    const exists = arr.some(x => String(x?.role || "").toLowerCase() === "dean");
    if (exists) return arr;

    const nextStage = arr.length ? Math.max(...arr.map(x => Number(x.stage)||0)) + 1 : 2;
    arr.push({
      stage: nextStage,
      role: "dean",
      email: normalizeEmail(deanEmail),
      action: "pending",
      acted_at: null,
      remark: ""
    });
    return arr;
  }

  function markMyChainAction(chain, action, remark){
    const arr = Array.isArray(chain) ? [...chain] : [];
    const meLower = currentUserEmailLower;
    const meRaw = currentUserEmailRaw;

    // Prefer updating my own entry (even if already acted)
    let idx = arr.findIndex(x => {
      const e = String(x?.email || "").trim();
      return e === meRaw || e.toLowerCase() === meLower;
    });

    if (idx >= 0){
      arr[idx] = { ...arr[idx], action, status: action, acted_at: isoNow(), actedAt: isoNow(), remark: remark || "" };
    } else {
      arr.push({
        stage: arr.length + 1,
        role: canDean ? "dean" : "approver_override",
        email: meLower,
        action,
        status: action,
        acted_at: isoNow(),
        remark: remark || ""
      });
    }

    return arr;
  }

  // ===== Change decision (History) =====
  async function handleChangeDecision(requestId, newAction){
    const r = cacheAllForApprover.find(x => x.id === requestId);
    if (!r) return;

    if (!didIAct(r.approver_chain)){
      alert("You did not act on this request.");
      return;
    }
    if (!isBeforeOutTime(r)){
      alert("Cannot change decision after OUT time.");
      return;
    }
    if (isEscalatedLocked(r)){
      alert("Cannot change once escalated to Dean / pending Dean.");
      return;
    }

    const remark = (document.getElementById(`chg_remark_${requestId}`)?.value || "").trim();
    const chain0 = Array.isArray(r.approver_chain) ? r.approver_chain : [];
    const chain = markMyChainAction(chain0, newAction, remark);

    // Derive overall status update based on original route stage role
    // Your system uses:
    // - Warden approvals are final
    // - Batch Coordinator approvals can be final OR escalated (but escalation is locked, so here it's always non-escalated)
    // - Dean approvals are final (but if dean action exists, escalation.requested would be true => locked already)
    const holderRoleL1 = String(r?.routing?.l1_role || "").toLowerCase(); // warden or batch_coordinator
    const finalStatus =
      (newAction === "approved")
        ? ( (String(r.status||"").toLowerCase() === "approved_dean_final") ? "approved_dean_final" : "approved_final" )
        : ( (String(r.status||"").toLowerCase() === "rejected_dean") ? "rejected_dean" : "rejected_l1" );

    const updates = {
      approver_chain: chain,
      approver_emails: (Array.isArray(r.approver_emails) ? r.approver_emails : []).length ? r.approver_emails : chain.map(x => normalizeEmail(x.email)).filter(Boolean),
      status: finalStatus,
      current: { holder_email: null, holder_role: "", stage: "" },
      current_holder_email: null,
      updated_at: serverTimestamp(),
      updatedAt: serverTimestamp(),
      // also ensure escalation stays false in non-escalated flow
      escalation: {
        ...(r.escalation || {}),
        requested: false,
        dean_action: "not_required"
      }
    };
console.log("UPDATE PAYLOAD KEYS:", Object.keys(updates));
console.log("UPDATE PAYLOAD:", JSON.stringify(updates, null, 2));
console.log("CURRENT STATUS:", r.status);
console.log("NEW STATUS:", updates.status);
console.log("CURRENT HOLDER:", r.current_holder_email, r.current?.holder_email);
console.log("OUT:", r.out_datetime);
    try{
      await updateDoc(doc(db, "leave_requests", requestId), updates);

      // Gatepass: if moving away from approved => revoke
      if (newAction !== "approved"){
        await revokePublicGatepass(requestId, "decision_changed_to_rejected");
      } else {
        // re-approve => re-publish gatepass_public
        await upsertPublicGatepass(requestId, { ...r, ...updates });
      }

      await refreshCache();
      computeDashboardMetrics();
      renderPendingRequests();
      renderHistory();
    }catch(e){
      console.error(e);
      alert("Unable to change decision. Check Firestore rules.");
    }
  }

  // ===== Approve / Reject (Pending page) =====
  async function handleApprove(requestId){
    const r = cacheAllForApprover.find(x => x.id === requestId);
    if (!r) return;
    if (!isPendingForMe(r)) return;

    const st = String(r.status || "").toLowerCase();
    const holderRole = getCurrentHolderRole(r).toLowerCase();

    const remark = (document.getElementById(`remark_${requestId}`)?.value || "").trim();
    const chain0 = Array.isArray(r.approver_chain) ? r.approver_chain : [];
    let chain = markMyChainAction(chain0, "approved", remark);

    const updates = {
      approver_chain: chain,
      approver_emails: (Array.isArray(r.approver_emails) ? r.approver_emails : []).length ? r.approver_emails : chain.map(x => normalizeEmail(x.email)).filter(Boolean),
      updated_at: serverTimestamp(),
      updatedAt: serverTimestamp()
    };

    let finalApproved = false;

    if (holderRole === "dean" || st === "pending_dean"){
      updates.status = "approved_dean_final";
      updates.current = { holder_email: null, holder_role: "", stage: "" };
      updates.current_holder_email = null;

      updates.escalation = { ...(r.escalation || {}), dean_action: "approved" };
      finalApproved = true;

    } else {

      // ✅ WARDEN approvals are ALWAYS FINAL
      if (holderRole === "warden") {
        updates.status = "approved_final";
        updates.current = { holder_email: null, holder_role: "", stage: "" };
        updates.current_holder_email = null;

        updates.escalation = {
          ...(r.escalation || {}),
          requested: false,
          dean_action: "not_required"
        };

        finalApproved = true;

      } else {
        // ✅ Batch Coordinator can still escalate optionally
        const deanEmail = r?.routing?.dean_email || "";
        const escEl = document.getElementById(`esc_${requestId}`);
        const wantEsc = !!(escEl && escEl.checked);

        if (wantEsc && deanEmail){
          chain = ensureDeanStage(chain, deanEmail);
          updates.approver_chain = chain;

          updates.status = "pending_dean";
          updates.current = { holder_email: normalizeEmail(deanEmail), holder_role: "dean", stage: "DEAN" };
          updates.current_holder_email = normalizeEmail(deanEmail);

          updates.escalation = {
            ...(r.escalation || {}),
            requested: true,
            requested_by: currentUserEmailLower,
            requested_at: serverTimestamp(),
            reason: ""
          };

        } else {
          updates.status = "approved_final";
          updates.current = { holder_email: null, holder_role: "", stage: "" };
          updates.current_holder_email = null;

          updates.escalation = {
            ...(r.escalation || {}),
            requested: false,
            dean_action: "not_required"
          };

          finalApproved = true;
        }
      }
    }

    try{
      await updateDoc(doc(db, "leave_requests", requestId), updates);

      if (finalApproved){
        await upsertPublicGatepass(requestId, { ...r, ...updates });
      }

      await refreshCache();
      computeDashboardMetrics();
      renderPendingRequests();
      renderHistory();
    }catch(e){
      console.error("UPDATE FAILED:", e.code, e.message);
  console.error("FAILED PAYLOAD KEYS:", Object.keys(updates));
  console.error("FAILED PAYLOAD:", updates);
  throw e;
      alert("Unable to approve. Check Firestore rules / indexes.");
    }
  }

  async function handleReject(requestId){
    const r = cacheAllForApprover.find(x => x.id === requestId);
    if (!r) return;
    if (!isPendingForMe(r)) return;

    const st = String(r.status || "").toLowerCase();
    const holderRole = getCurrentHolderRole(r).toLowerCase();

    const remark = (document.getElementById(`remark_${requestId}`)?.value || "").trim();
    const chain0 = Array.isArray(r.approver_chain) ? r.approver_chain : [];
    const chain = markMyChainAction(chain0, "rejected", remark);

    const updates = {
      approver_chain: chain,
      approver_emails: (Array.isArray(r.approver_emails) ? r.approver_emails : []).length ? r.approver_emails : chain.map(x => normalizeEmail(x.email)).filter(Boolean),
      updated_at: serverTimestamp(),
      updatedAt: serverTimestamp(),
      current: { holder_email: null, holder_role: "", stage: "" },
      current_holder_email: null
    };

    if (holderRole === "dean" || st === "pending_dean"){
      updates.status = "rejected_dean";
      updates.escalation = { ...(r.escalation || {}), dean_action: "rejected" };
    } else {
      updates.status = "rejected_l1";
      updates.escalation = {
        ...(r.escalation || {}),
        requested: false,
        dean_action: "not_required"
      };
    }
    try{
      await updateDoc(doc(db, "leave_requests", requestId), updates);

      // If it was previously approved and gatepass exists => revoke it
      await revokePublicGatepass(requestId, "rejected");

      await refreshCache();
      computeDashboardMetrics();
      renderPendingRequests();
      renderHistory();
    }catch(e){
      console.error(e);
      alert("Unable to reject. Check Firestore rules / indexes.");
    }
  }

  // ===== Buttons / events =====
  logoutBtn.addEventListener("click", async () => {
    try{ await signOut(auth); }catch(_){}
    window.location.replace("../index.html");
  });

  tabDashboard.addEventListener("click", () => showPage("dashboard"));
  tabRequests.addEventListener("click", () => { showPage("requests"); renderPendingRequests(); });
  tabHistory.addEventListener("click", () => { showPage("history"); renderHistory(); });

  applyFilters.addEventListener("click", async () => {
    dashFrom = fFrom.value || "";
    dashTo = fTo.value || "";
    await refreshCache();
    computeDashboardMetrics();
    renderHistory();
  });

  applyReqFilters.addEventListener("click", () => {
    reqFrom = rFrom.value || "";
    reqTo = rTo.value || "";
    renderPendingRequests();
  });

  hApproved.addEventListener("click", () => setHistoryTab("approved"));
  hRejected.addEventListener("click", () => setHistoryTab("rejected"));
  hEscalated.addEventListener("click", () => setHistoryTab("escalated"));
  hIntimation.addEventListener("click", () => setHistoryTab("intimation"));

  hApplyFilters.addEventListener("click", () => renderHistory());
  hClearFilters.addEventListener("click", () => {
    hFrom.value = "";
    hTo.value = "";
    hRoll.value = "";
    hYear.value = "all";
    hHostel.value = "all";
    hReason.value = "all";
    hLateOnly.value = "no";
    hNotVerifiedOnly.value = "no";
    renderHistory();
  });

  // ===== Reports UI =====
  function setRepMode(mode){
    repMode = mode;
    repModeTime.classList.toggle("active", mode === "time");
    repModeStudent.classList.toggle("active", mode === "student");
    repRollBox.style.display = (mode === "student") ? "block" : "none";
    repToast.className = "toast";
    repToast.textContent = "";
  }
  repModeTime.addEventListener("click", () => setRepMode("time"));
  repModeStudent.addEventListener("click", () => setRepMode("student"));

  function todayDateStr(){
    const d = new Date();
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    return `${yyyy}-${mm}-${dd}`;
  }
  function addDays(dateObj, days){
    const d = new Date(dateObj);
    d.setDate(d.getDate() + days);
    return d;
  }
  function dateToStr(d){
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    return `${yyyy}-${mm}-${dd}`;
  }
  function applyPreset(days){
    const now = new Date();
    const from = addDays(now, -days);
    repFrom.value = dateToStr(from);
    repTo.value = todayDateStr();
    repToast.className = "toast";
    repToast.textContent = "";
  }
  repPreset7.addEventListener("click", () => applyPreset(7));
  repPreset30.addEventListener("click", () => applyPreset(30));
  repPresetThisMonth.addEventListener("click", () => {
    const now = new Date();
    const first = new Date(now.getFullYear(), now.getMonth(), 1);
    repFrom.value = dateToStr(first);
    repTo.value = todayDateStr();
    repToast.className = "toast";
    repToast.textContent = "";
  });

  repClear.addEventListener("click", () => {
    repFrom.value = "";
    repTo.value = "";
    repYear.value = "all";
    repRoll.value = "";
    setRepMode("time");
    repToast.className = "toast";
    repToast.textContent = "";
  });

  async function fetchFinalApprovedRowsForReport({ fromDate, toDate, year, roll }){
    if (!fromDate || !toDate) throw new Error("Please select From & To dates (IN datetime).");

    const { start, end } = dateRangeToTimestamps(fromDate, toDate);
    if (!start || !end) throw new Error("Invalid date range.");

    const qLower = query(
      collection(db, "leave_requests"),
      where("approver_emails", "array-contains", currentUserEmailLower),
      where("in_datetime", ">=", start),
      where("in_datetime", "<=", end)
    );
    const qRaw = query(
      collection(db, "leave_requests"),
      where("approver_emails", "array-contains", currentUserEmailRaw),
      where("in_datetime", ">=", start),
      where("in_datetime", "<=", end)
    );

    let rows = await tryGetDocs(qLower, qRaw);

    rows = rows.filter(r => isFinalApprovedStatus(r.status));
    rows = rows.filter(r => didIAct(r.approver_chain) === "approved");

    if (year && year !== "all"){
      rows = rows.filter(r => String(getStudentYear(r)) === String(year));
    }
    if (roll){
      const rr = normalizeRollno(roll);
      rows = rows.filter(r => normalizeRollno(r.student_rollno || "") === rr);
    }

    rows.sort((a,b) => (toJSDate(getInDT(a))?.getTime()||0) - (toJSDate(getInDT(b))?.getTime()||0));
    return rows;
  }

  function buildReportFilename({ mode, fromDate, toDate, roll }){
    const role = (roleType === "dean") ? "Dean" : "Approver";
    const base = `${role}_Report_${fromDate}_to_${toDate}`;
    if (mode === "student" && roll) return `${base}_${normalizeRollno(roll)}.pdf`;
    return `${base}.pdf`;
  }

  function buildPDF({ rows, mode, fromDate, toDate, year, roll }){
    const { jsPDF } = window.jspdf;
    const docPDF = new jsPDF({ orientation: "portrait", unit: "pt", format: "a4" });
    const pageW = docPDF.internal.pageSize.getWidth();

    docPDF.setFont("helvetica", "bold");
    docPDF.setFontSize(14);
    docPDF.text("Xavier Institute of Management and Entrepreneurship (XIME)", 40, 42);

    docPDF.setFontSize(12);
    docPDF.setTextColor(193, 18, 31);
    docPDF.text("Leave Management System — Final Approved Requests Report", 40, 62);
    docPDF.setTextColor(15, 23, 42);

    docPDF.setDrawColor(193, 18, 31);
    docPDF.setLineWidth(2);
    docPDF.line(40, 74, pageW - 40, 74);

    docPDF.setFont("helvetica", "normal");
    docPDF.setFontSize(10);

    const genAt = new Date().toLocaleString();
    const who = `${apName.textContent || "Approver"} (${currentUserEmailRaw})`;
    const yearText = (year && year !== "all") ? `Year ${year}` : "All Years";

    const lines = [
      `Prepared by: ${who}`,
      `Generated: ${genAt}`,
      `IN datetime range: ${fromDate} to ${toDate}`,
      `Year Filter: ${yearText}`,
      mode === "student" ? `Student Roll No: ${normalizeRollno(roll || "")}` : `Mode: Timeframe (All Final Approved by Me)`,
    ];

    let y = 92;
    lines.forEach((t) => { docPDF.text(t, 40, y); y += 14; });

    docPDF.setFont("helvetica", "bold");
    docPDF.text(`Total Records: ${rows.length}`, 40, y + 6);
    docPDF.setFont("helvetica", "normal");

    const tableBody = rows.map((r, idx) => {
      const studentName = r.student_name || "";
      const rollno = normalizeRollno(r.student_rollno || "");
      const yearVal = getStudentYear(r) || "";
      const hostel = String(r.student_hostel || "").trim();
      const room = String(r.student_room_no || "").trim();
      const outVal = getOutDT(r);
      const inVal  = getInDT(r);
      const contact = String(r.contact_no || "").trim();

      const arrivalStatus = getArrivalStatusText(r);

      const reasonCat = String(r.reason_category || "—").trim();
      const reasonTxt = String(r.reason_text || r.reason || "").trim();
      const reason = reasonTxt ? `${reasonCat} — ${reasonTxt}` : reasonCat;

      return [
        String(idx + 1),
        rollno || "—",
        studentName || "—",
        yearVal || "—",
        hostel || "—",
        room || "—",
        fmtDT(outVal),
        fmtDT(inVal),
        arrivalStatus,
        contact || "—",
        reason || "—"
      ];
    });

    docPDF.autoTable({
      startY: y + 18,
      head: [[
        "S.No","Roll No","Student Name","Year","Hostel","Room",
        "Out Date & Time","In Date & Time",
        "Arrival Status",
        "Contact","Reason"
      ]],
      body: tableBody,
      styles: { font: "helvetica", fontSize: 8, cellPadding: 4, overflow: "linebreak" },
      headStyles: { fillColor: [193, 18, 31], textColor: 255, fontStyle: "bold" },
      alternateRowStyles: { fillColor: [248, 250, 252] },
      margin: { left: 40, right: 40 },
      theme: "striped",
      didDrawPage: () => {
        const pageCount = docPDF.internal.getNumberOfPages();
        const pageCurrent = docPDF.internal.getCurrentPageInfo().pageNumber;
        docPDF.setFontSize(9);
        docPDF.setTextColor(100);
        docPDF.text(`Page ${pageCurrent} of ${pageCount}`, pageW - 90, docPDF.internal.pageSize.getHeight() - 20);
        docPDF.setTextColor(15, 23, 42);
      }
    });

    return docPDF;
  }

  repDownload.addEventListener("click", async () => {
    repToast.className = "toast";
    repToast.textContent = "";

    try{
      repDownload.disabled = true;

      const fromDate = repFrom.value || "";
      const toDate = repTo.value || "";
      const year = repYear.value || "all";
      const roll = (repMode === "student") ? (repRoll.value || "") : "";

      if (repMode === "student" && !roll.trim()){
        repToast.className = "toast show bad";
        repToast.textContent = "Enter Student Roll No for Student-wise report.";
        return;
      }

      repToast.className = "toast show good";
      repToast.textContent = "Preparing report…";

      const rows = await fetchFinalApprovedRowsForReport({ fromDate, toDate, year, roll });

      if (!rows.length){
        repToast.className = "toast show bad";
        repToast.textContent = "No final approved records found for the selected filters.";
        return;
      }

      const pdf = buildPDF({ rows, mode: repMode, fromDate, toDate, year, roll });
      const filename = buildReportFilename({ mode: repMode, fromDate, toDate, roll });

      pdf.save(filename);
      repToast.className = "toast show good";
      repToast.textContent = "Downloaded successfully ✅";

    }catch(err){
      console.error(err);
      repToast.className = "toast show bad";
      repToast.textContent = err?.message || "Unable to generate report. Check Firestore indexes / permissions.";
    }finally{
      repDownload.disabled = false;
    }
  });

  // ===== Auth boot =====
  onAuthStateChanged(auth, async (u) => {
    if (!u){
      window.location.replace("../index.html");
      return;
    }

    currentUserEmailRaw = String(u.email || "").trim();
    currentUserEmailLower = currentUserEmailRaw.toLowerCase();

    try{
      roleDoc = await loadRoleDoc();

      if (roleDoc?.is_active === false){
        throw new Error("Access denied. Your account is inactive.");
      }

      computeCapabilitiesFromRoleDoc(roleDoc);

      if (!canBC && !canWarden && !canDean){
        throw new Error("Access denied. You are not assigned as Batch Coordinator / Warden / Dean.");
      }

      updateApproverUI();
      showPage("dashboard");

      // default report dates: this month
      const now = new Date();
      const first = new Date(now.getFullYear(), now.getMonth(), 1);
      repFrom.value = dateToStr(first);
      repTo.value = todayDateStr();
      setRepMode("time");

      await refreshCache();
      computeDashboardMetrics();
      updateHistoryCounts();
      renderPendingRequests();
      renderHistory();

    }catch(err){
      console.error(err);
      alert(err?.message || "Unable to load approver role/data. Contact Admin.");
      try{ await signOut(auth); }catch(_){}
      window.location.replace("../index.html");
    }
  });
</script>
</body>
</html>




