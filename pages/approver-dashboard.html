<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>XIME — Approver Dashboard</title>

<style>
:root{
  --red:#c1121f;
  --redDark:#9b0f19;
  --ink:#0f172a;
  --muted:#64748b;
  --line:#e2e8f0;
  --soft:#f8fafc;
  --card:#ffffff;

  --good:#0f766e;
  --bad:#b42318;
  --warn:#b54708;

  --shadow: 0 18px 55px rgba(2,6,23,.10);
  --shadow2: 0 10px 24px rgba(2,6,23,.08);

  --radius:18px;
  --radius2:14px;
  --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
}

*{box-sizing:border-box}
body{
  margin:0;
  font-family:var(--font);
  background:
    radial-gradient(1000px 520px at 20% 0%, rgba(193,18,31,.08), transparent 55%),
    radial-gradient(900px 500px at 90% 10%, rgba(193,18,31,.06), transparent 55%),
    linear-gradient(180deg, #fff 0%, #fff 70%, #fafafa 100%);
  color:var(--ink);
}

.topbar{
  position:sticky; top:0; z-index:10;
  background: rgba(255,255,255,.92);
  backdrop-filter: blur(10px);
  border-bottom:1px solid var(--line);
}
.topbarInner{
  max-width:1200px;
  margin:auto;
  padding:14px 18px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
}
.brand{ display:flex; gap:12px; align-items:center; min-width:0; }
.brand img{ width:110px; max-height:54px; object-fit:contain; display:block; }
.brandText{ line-height:1.1; min-width:0; }
.brandText .inst{ font-size:14px; font-weight:900; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; color:#0f172a; }
.brandText .sys{ font-size:18px; font-weight:950; color:var(--red); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

.btn{
  border:none;
  border-radius:14px;
  padding:10px 14px;
  font-weight:950;
  cursor:pointer;
  color:#fff;
  background:linear-gradient(135deg,var(--red),var(--redDark));
  box-shadow: 0 12px 26px rgba(193,18,31,.20);
  transition:.15s ease;
}
.btn:hover{ transform: translateY(-1px); box-shadow: 0 16px 34px rgba(193,18,31,.25); }
.btn:active{ transform: translateY(0px) scale(.99); }
.btn:disabled{ opacity:.6; cursor:not-allowed; transform:none; box-shadow:none; }

.wrap{ max-width:1200px; margin:auto; padding:20px 18px 28px; }

.mainTabs{
  display:flex; gap:10px; flex-wrap:wrap; margin-bottom:14px;
}
.mainTab{
  border:1px solid var(--line);
  background:#fff;
  padding:10px 12px;
  border-radius:14px;
  cursor:pointer;
  font-weight:950;
  font-size:13px;
  color:#0f172a;
  transition:.15s ease;
  min-width:160px;
  text-align:center;
  box-shadow: 0 8px 18px rgba(2,6,23,.05);
}
.mainTab:hover{ border-color: rgba(193,18,31,.35); transform: translateY(-1px); }
.mainTab.active{
  border-color: rgba(193,18,31,.55);
  background: rgba(193,18,31,.06);
  color: var(--redDark);
  box-shadow: 0 14px 28px rgba(193,18,31,.10);
}

.panel{
  background:var(--card);
  border:1px solid var(--line);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  overflow:hidden;
}
.panelHead{
  padding:14px 16px 10px;
  border-bottom:1px solid var(--line);
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:10px;
}
.panelTitle{ margin:0; font-size:16px; font-weight:1000; }
.panelBody{ padding:14px 16px 16px; }
.hidden{ display:none !important; }

.headerGrid{
  display:grid;
  grid-template-columns: 340px 1fr;
  gap:14px;
  margin-bottom:14px;
  align-items: start;
}
@media(max-width: 900px){ .headerGrid{ grid-template-columns:1fr; } }

/* Profile */
.approverName{ font-size:18px; font-weight:1050; letter-spacing:.2px; }
.approverMeta{
  margin-top:8px;
  font-size:13px;
  color:#0f172a;
  font-weight:750;
  line-height:1.6;
}
.metaLine{
  padding:8px 10px;
  border-radius:14px;
  border:1px solid var(--line);
  background: rgba(15,23,42,.02);
  margin-top:8px;
}
.metaLine b{ color: var(--redDark); }

/* Filters / Dashboard */
.filterBar{
  display:grid;
  grid-template-columns: 1fr 1fr 140px;
  gap:10px;
  margin-bottom:12px;
}
@media(max-width: 980px){ .filterBar{ grid-template-columns:1fr 1fr; } }
.filterBox{
  border:1px solid var(--line);
  border-radius:16px;
  background:var(--soft);
  padding:10px 12px;
}
.filterBox label{
  display:block;
  font-size:11px;
  color:var(--muted);
  font-weight:900;
  letter-spacing:.2px;
  margin-bottom:6px;
}
select, input{
  width:100%;
  border:1px solid var(--line);
  border-radius:14px;
  padding:10px 10px;
  font-size:13px;
  font-weight:800;
  outline:none;
  background:#fff;
}
select:focus, input:focus{
  border-color: rgba(193,18,31,.55);
  box-shadow: 0 0 0 4px rgba(193,18,31,.12);
}
.applyBtn{
  height:42px;
  align-self:end;
  border:none;
  border-radius:14px;
  padding:0 14px;
  background: linear-gradient(135deg, var(--red), var(--redDark));
  color:#fff;
  font-weight:950;
  cursor:pointer;
  box-shadow: 0 12px 26px rgba(193,18,31,.18);
  transition:.15s ease;
}
.applyBtn:hover{ transform: translateY(-1px); box-shadow: 0 16px 34px rgba(193,18,31,.22); }
.applyBtn:disabled{ opacity:.6; cursor:not-allowed; transform:none; box-shadow:none; }

.metrics{ display:grid; grid-template-columns: repeat(4, 1fr); gap:10px; }
@media(max-width: 1050px){ .metrics{ grid-template-columns: repeat(2, 1fr); } }
.metric{
  border:1px solid var(--line);
  border-radius:16px;
  background:var(--soft);
  padding:12px;
  box-shadow: var(--shadow2);
}
.metric .k{ font-size:11px; color:var(--muted); font-weight:950; letter-spacing:.2px; }
.metric .v{ margin-top:6px; font-size:24px; font-weight:1100; }

/* Reports */
.reportsGrid{
  margin-top:14px;
  display:grid;
  grid-template-columns: 1fr;
  gap:14px;
}
.reportIntro{
  color:var(--muted);
  font-weight:800;
  font-size:12.5px;
  line-height:1.45;
}
.pills{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  margin:10px 0 12px;
}
.pill{
  border:1px solid var(--line);
  background:#fff;
  padding:10px 12px;
  border-radius:999px;
  cursor:pointer;
  font-weight:950;
  font-size:13px;
  transition:.15s ease;
  box-shadow: 0 10px 22px rgba(2,6,23,.06);
}
.pill:hover{ transform: translateY(-1px); border-color: rgba(193,18,31,.35); }
.pill.active{
  background: rgba(193,18,31,.08);
  border-color: rgba(193,18,31,.55);
  color: var(--redDark);
  box-shadow: 0 14px 28px rgba(193,18,31,.10);
}

.reportRow{
  display:grid;
  grid-template-columns: 1.2fr 1fr 1fr 1fr 170px;
  gap:10px;
}
@media(max-width: 1100px){ .reportRow{ grid-template-columns: 1fr 1fr; } }

.smallBtns{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
.btnGhost{
  border:1px solid var(--line);
  background:#fff;
  color:#0f172a;
  border-radius:14px;
  padding:10px 12px;
  font-weight:950;
  cursor:pointer;
  transition:.15s ease;
  box-shadow: 0 10px 22px rgba(2,6,23,.06);
}
.btnGhost:hover{ transform: translateY(-1px); border-color: rgba(193,18,31,.35); }

.toast{
  margin-top:12px;
  border-radius:14px;
  padding:10px 12px;
  border:1px solid var(--line);
  background:#fff;
  display:none;
  font-size:13px;
  line-height:1.45;
  font-weight:750;
}
.toast.show{ display:block; }
.toast.good{ border-color: rgba(15,118,110,.25); background: rgba(15,118,110,.06); color:#0f3d39; }
.toast.bad{ border-color: rgba(180,35,24,.22); background: rgba(180,35,24,.06); color:#5a1110; }

/* History Tabs */
.statusTabs{ display:flex; gap:10px; margin-bottom:12px; flex-wrap:wrap; }
.statusTab{
  padding:9px 12px;
  border-radius:999px;
  border:1px solid var(--line);
  background:#fff;
  font-weight:950;
  cursor:pointer;
  transition:.15s ease;
  display:flex; align-items:center; gap:8px;
  box-shadow: 0 10px 22px rgba(2,6,23,.06);
}
.statusTab:hover{ transform: translateY(-1px); border-color: rgba(193,18,31,.35); }
.statusTab.active{
  background:rgba(193,18,31,.08);
  border-color:rgba(193,18,31,.5);
  color:var(--redDark);
}
.count{
  border:1px solid var(--line);
  background:#fff;
  border-radius:999px;
  padding:3px 8px;
  font-size:12px;
  font-weight:950;
  min-width:30px;
  text-align:center;
}

/* Cards */
.requestCard{
  background:#fff;
  border:1px solid var(--line);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  padding:16px;
  margin-bottom:14px;
}
.cardTop{ display:flex; justify-content:space-between; align-items:flex-start; gap:10px; flex-wrap:wrap; }
.studentBlock{ display:flex; gap:12px; align-items:center; min-width:0; }

.studentPhoto{
  width:70px; height:92px;
  border-radius:18px;
  border:1px solid var(--line);
  background:var(--soft);
  object-fit:cover;
  display:block;
}
.studentAvatar{
  width:70px; height:92px;
  border-radius:18px;
  border:1px dashed rgba(193,18,31,.35);
  background: rgba(193,18,31,.05);
  display:grid;
  place-items:center;
  color:var(--redDark);
  font-weight:1100;
  letter-spacing:.5px;
  text-transform:uppercase;
}
.studentText{ min-width:0; }
.studentName{ font-size:18px; font-weight:1050; }
.studentMeta{ margin-top:4px; font-size:13.5px; color:var(--muted); font-weight:750; }

.reqCountLine{
  margin-top:8px;
  padding:8px 10px;
  border-radius:14px;
  background: rgba(193,18,31,.06);
  border: 1px dashed rgba(193,18,31,.35);
  color: var(--redDark);
  font-weight:900;
  font-size:13px;
}

.badge{
  padding:7px 12px;
  border-radius:999px;
  font-size:12px;
  font-weight:950;
  white-space:nowrap;
}
.pending{background:rgba(181,71,8,.08); color:var(--warn)}
.approved{background:rgba(15,118,110,.08); color:var(--good)}
.rejected{background:rgba(180,35,24,.08); color:var(--bad)}

.details{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:12px;
  margin-top:14px;
}
@media(max-width:700px){ .details{ grid-template-columns:1fr } }

.kv{
  background:var(--soft);
  border-radius:16px;
  padding:12px;
  border:1px solid var(--line);
}
.kv .k{ font-size:11px; color:var(--muted); font-weight:900; letter-spacing:.2px; }
.kv .v{ margin-top:6px; font-size:15px; font-weight:1000; letter-spacing:.1px; }
.reasonBox{ grid-column:1/-1; }

textarea{
  width:100%;
  margin-top:10px;
  padding:12px;
  border-radius:16px;
  border:1px solid var(--line);
  font-family:var(--font);
  font-size:14px;
  resize:vertical;
  min-height:86px;
  outline:none;
}
textarea:focus{
  border-color: rgba(193,18,31,.55);
  box-shadow: 0 0 0 4px rgba(193,18,31,.12);
}

.actions{ margin-top:12px; display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
.actionBtn{
  border:none;
  padding:11px 18px;
  border-radius:16px;
  font-weight:1050;
  cursor:pointer;
  transition: .15s ease;
  box-shadow: 0 12px 24px rgba(2,6,23,.14);
  letter-spacing:.2px;
  color:#fff;
}
.actionBtn:hover{ transform: translateY(-1px); box-shadow: 0 16px 34px rgba(2,6,23,.18); }
.actionBtn:active{ transform: translateY(0px) scale(.99); }
.actionBtn:disabled{ cursor:not-allowed; opacity:.55; transform:none; box-shadow:none; }

.approveBtn{ background: linear-gradient(135deg, var(--good), #14b8a6); }
.rejectBtn{ background: linear-gradient(135deg, var(--bad), #ff3b3b); }

.inlineOpt{
  display:flex; align-items:center; gap:10px; flex-wrap:wrap;
  padding:10px 12px; border-radius:16px; border:1px dashed rgba(193,18,31,.3);
  background: rgba(193,18,31,.04);
  margin-top:10px;
  font-weight:900;
  color: var(--redDark);
}
.inlineOpt input{ width:auto; }
.smallNote{ font-size:12px; color:var(--muted); font-weight:850; margin-top:8px; line-height:1.4; }
</style>
</head>

<body>
<div class="topbar">
  <div class="topbarInner">
    <div class="brand">
      <img src="../assets/img/xime-logo.jpg" alt="XIME Logo">
      <div class="brandText">
        <div class="inst">Xavier Institute of Management and Entrepreneurship</div>
        <div class="sys">Leave Management System</div>
      </div>
    </div>
    <button class="btn" id="logoutBtn" type="button">Logout</button>
  </div>
</div>

<div class="wrap">
  <div class="mainTabs">
    <div class="mainTab active" id="tabDashboard" type="button">Dashboard</div>
    <div class="mainTab" id="tabRequests" type="button">Requests</div>
    <div class="mainTab" id="tabHistory" type="button">History</div>
  </div>

  <!-- DASHBOARD -->
  <section id="pageDashboard">
    <div class="headerGrid">

      <section class="panel">
        <div class="panelHead">
          <h3 class="panelTitle">My Profile</h3>
        </div>
        <div class="panelBody">
          <div class="approverName" id="apName">—</div>

          <div class="approverMeta">
            <div class="metaLine" id="lineEmail"><b>Email</b> — <span id="apEmail">—</span></div>
            <div class="metaLine" id="lineWarden" style="display:none;"><b>Warden</b> — <span id="apWarden">—</span></div>
            <div class="metaLine" id="lineBC" style="display:none;"><b>Batch Coordinator</b> — <span id="apBC">—</span></div>
            <div class="metaLine" id="lineDean" style="display:none;"><b>Dean</b> — <span id="apDean">Active</span></div>
          </div>
        </div>
      </section>

      <section class="panel">
        <div class="panelHead">
          <h3 class="panelTitle">Dashboard</h3>
        </div>
        <div class="panelBody">
          <div class="filterBar">
            <div class="filterBox">
              <label>From Date (Out)</label>
              <input id="fFrom" type="date">
            </div>
            <div class="filterBox">
              <label>To Date (Out)</label>
              <input id="fTo" type="date">
            </div>
            <button class="applyBtn" type="button" id="applyFilters">Apply</button>
          </div>

          <div class="metrics">
            <div class="metric"><div class="k">TOTAL (IN SCOPE)</div><div class="v" id="mTotal">0</div></div>
            <div class="metric"><div class="k">PENDING FOR ME</div><div class="v" id="mPending">0</div></div>
            <div class="metric"><div class="k">APPROVED BY ME</div><div class="v" id="mApproved">0</div></div>
            <div class="metric"><div class="k">REJECTED BY ME</div><div class="v" id="mRejected">0</div></div>
          </div>
        </div>
      </section>

    </div>

    <!-- REPORTS -->
    <div class="reportsGrid">
      <section class="panel">
        <div class="panelHead">
          <h3 class="panelTitle">Reports (Download PDF)</h3>
          <div class="smallBtns">
            <button class="btnGhost" id="repClear" type="button">Clear</button>
          </div>
        </div>
        <div class="panelBody">
          <div class="reportIntro">
            Download PDF for <b>Final Approved</b> requests that were <b>approved by you</b> at your stage.
            Includes <b>Actual In Time</b> + <b>Late By</b> and also a <b>Late Comers</b> list.
          </div>

          <div class="pills">
            <button class="pill active" id="repModeTime" type="button">Timeframe (All Final Approved by Me)</button>
            <button class="pill" id="repModeStudent" type="button">Student-wise (Roll No + Timeframe)</button>
          </div>

          <div class="reportRow">
            <div class="filterBox" id="repRollBox" style="display:none;">
              <label>Student Roll No</label>
              <input id="repRoll" type="text" placeholder="e.g., C08080" />
            </div>

            <div class="filterBox">
              <label>From Date (IN)</label>
              <input id="repFrom" type="date" />
            </div>

            <div class="filterBox">
              <label>To Date (IN)</label>
              <input id="repTo" type="date" />
            </div>

            <div class="filterBox">
              <label>Year</label>
              <select id="repYear">
                <option value="all">All</option>
                <option value="1">Year 1</option>
                <option value="2">Year 2</option>
              </select>
            </div>

            <button class="applyBtn" id="repDownload" type="button">Download PDF</button>
          </div>

          <div class="pills" style="margin-top:10px;">
            <button class="pill" id="repPreset7" type="button">Last 7 Days</button>
            <button class="pill" id="repPreset30" type="button">Last 30 Days</button>
            <button class="pill" id="repPresetThisMonth" type="button">This Month</button>
          </div>

          <div id="repToast" class="toast"></div>
        </div>
      </section>
    </div>
  </section>

  <!-- REQUESTS (PENDING ONLY) -->
  <section id="pageRequests" class="hidden">
    <div id="reqFilterWrap" class="filterBar" style="grid-template-columns: 1fr 1fr 140px; margin-bottom:12px;">
      <div class="filterBox">
        <label>From Date (Out)</label>
        <input id="rFrom" type="date">
      </div>
      <div class="filterBox">
        <label>To Date (Out)</label>
        <input id="rTo" type="date">
      </div>
      <button class="applyBtn" type="button" id="applyReqFilters">Apply</button>
    </div>

    <div class="smallNote">
      ✅ This page shows only <b>pending requests assigned to you</b> (L1 or Dean).  
      Escalation to Dean can be selected while approving.
    </div>

    <div id="requestsContainer"></div>
  </section>

  <!-- HISTORY -->
  <section id="pageHistory" class="hidden">
    <div class="statusTabs">
      <div class="statusTab active" id="hApproved">Approved <span class="count" id="hcApproved">0</span></div>
      <div class="statusTab" id="hRejected">Rejected <span class="count" id="hcRejected">0</span></div>
      <div class="statusTab" id="hEscalated">Escalated to Dean <span class="count" id="hcEscalated">0</span></div>
    </div>

    <div id="historyContainer"></div>
  </section>

</div>

<!-- PDF libs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
  import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
  import {
    getFirestore, doc, getDoc, collection, getDocs, query, where, updateDoc,
    serverTimestamp, setDoc
  } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

  window.addEventListener("pageshow", (e) => {
    if (e.persisted) window.location.reload();
  });

  const firebaseConfig = {
    apiKey: "AIzaSyDgoq2rMU5kiKcz_27-hjBzd8rxS8yQqdY",
    authDomain: "xime-leave-system-b25a4.firebaseapp.com",
    projectId: "xime-leave-system-b25a4",
    storageBucket: "xime-leave-system-b25a4.firebasestorage.app",
    messagingSenderId: "802112635142",
    appId: "1:802112635142:web:0fd0f5ad1ae3ef8eb4de87"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  // ===== DOM =====
  const logoutBtn = document.getElementById("logoutBtn");
  const tabDashboard = document.getElementById("tabDashboard");
  const tabRequests  = document.getElementById("tabRequests");
  const tabHistory   = document.getElementById("tabHistory");

  const pageDashboard = document.getElementById("pageDashboard");
  const pageRequests  = document.getElementById("pageRequests");
  const pageHistory   = document.getElementById("pageHistory");

  // Profile nodes
  const apName = document.getElementById("apName");
  const apEmail = document.getElementById("apEmail");
  const lineWarden = document.getElementById("lineWarden");
  const apWarden = document.getElementById("apWarden");
  const lineBC = document.getElementById("lineBC");
  const apBC = document.getElementById("apBC");
  const lineDean = document.getElementById("lineDean");
  const apDean = document.getElementById("apDean");

  // Dashboard filters
  const fFrom = document.getElementById("fFrom");
  const fTo   = document.getElementById("fTo");
  const applyFilters = document.getElementById("applyFilters");

  // Metrics
  const mTotal = document.getElementById("mTotal");
  const mPending = document.getElementById("mPending");
  const mApproved = document.getElementById("mApproved");
  const mRejected = document.getElementById("mRejected");

  // Requests filter
  const rFrom = document.getElementById("rFrom");
  const rTo = document.getElementById("rTo");
  const applyReqFilters = document.getElementById("applyReqFilters");

  const requestsContainer = document.getElementById("requestsContainer");
  const historyContainer = document.getElementById("historyContainer");

  // History tabs
  const hApproved = document.getElementById("hApproved");
  const hRejected = document.getElementById("hRejected");
  const hEscalated = document.getElementById("hEscalated");
  const hcApproved = document.getElementById("hcApproved");
  const hcRejected = document.getElementById("hcRejected");
  const hcEscalated = document.getElementById("hcEscalated");

  // Reports DOM
  const repModeTime = document.getElementById("repModeTime");
  const repModeStudent = document.getElementById("repModeStudent");
  const repRollBox = document.getElementById("repRollBox");
  const repRoll = document.getElementById("repRoll");
  const repFrom = document.getElementById("repFrom");
  const repTo = document.getElementById("repTo");
  const repYear = document.getElementById("repYear");
  const repDownload = document.getElementById("repDownload");
  const repToast = document.getElementById("repToast");
  const repClear = document.getElementById("repClear");
  const repPreset7 = document.getElementById("repPreset7");
  const repPreset30 = document.getElementById("repPreset30");
  const repPresetThisMonth = document.getElementById("repPresetThisMonth");

  // ===== State =====
  let repMode = "time"; // time | student

  let currentUserEmailRaw = "";
  let currentUserEmailLower = "";
  let roleDoc = null;
  let roleType = "approver"; // approver | dean

  let canBC = false;
  let canWarden = false;
  let canDean = false;

  let dashFrom = "";
  let dashTo = "";
  let reqFrom = "";
  let reqTo = "";

  let activeHistoryTab = "approved"; // approved | rejected | escalated

  let cacheAllForApprover = []; // pending + acted by me + escalated
  const rosterPhotoCache = new Map();
  const IMG_PLACEHOLDER = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";

  // ===== Helpers =====
  function showToast(el, msg, type="good"){
    el.className = "toast show " + (type === "bad" ? "bad" : "good");
    el.textContent = msg;
  }
  function clearToast(el){ el.className = "toast"; el.textContent = ""; }

  function isoNow(){ return new Date().toISOString(); }
  function normalizeEmail(v){ return String(v || "").trim().toLowerCase(); }
  function normalizeRollno(v){ return String(v || "").trim().toUpperCase(); }

  const YEAR_TO_BATCH = { "1":"Batch 9", "2":"Batch 8" };

  function showPage(which){
    [tabDashboard, tabRequests, tabHistory].forEach(x => x.classList.remove("active"));
    [pageDashboard, pageRequests, pageHistory].forEach(x => x.classList.add("hidden"));

    if(which === "dashboard"){
      tabDashboard.classList.add("active");
      pageDashboard.classList.remove("hidden");
    } else if (which === "requests") {
      tabRequests.classList.add("active");
      pageRequests.classList.remove("hidden");
    } else {
      tabHistory.classList.add("active");
      pageHistory.classList.remove("hidden");
    }
  }

  function toStartOfDayISO(dateStr){ return dateStr ? `${dateStr}T00:00` : ""; }
  function toEndOfDayISO(dateStr){ return dateStr ? `${dateStr}T23:59` : ""; }

  function getOutDT(row){ return row.out_datetime || row.outDT || row.outDateTime || ""; }
  function getInDT(row){ return row.in_datetime || row.inDT || row.inDateTime || ""; }

  function getCurrentHolderEmail(row){
    return String(row?.current?.holder_email || row?.current_holder_email || row?.currentHolderEmail || row?.current_holder || "").trim();
  }
  function getCurrentHolderRole(row){
    return String(row?.current?.holder_role || row?.current_holder_role || row?.currentRole || "").trim();
  }

  function inDateRangeOutDT(row, fromDate, toDate){
    const outDT = getOutDT(row);
    if (!outDT) return false;
    const out = String(outDT);
    if (fromDate){
      const fromISO = toStartOfDayISO(fromDate);
      if (out < fromISO) return false;
    }
    if (toDate){
      const toISO = toEndOfDayISO(toDate);
      if (out > toISO) return false;
    }
    return true;
  }

  function inDateRangeInDT(row, fromDate, toDate){
    const inDT = getInDT(row);
    if (!inDT) return false;
    const inn = String(inDT);
    if (fromDate){
      const fromISO = toStartOfDayISO(fromDate);
      if (inn < fromISO) return false;
    }
    if (toDate){
      const toISO = toEndOfDayISO(toDate);
      if (inn > toISO) return false;
    }
    return true;
  }

  function fmtDT(val){
    // supports Timestamp / ISO string
    let dt = null;
    if (!val) return "-";
    if (typeof val?.toDate === "function") dt = val.toDate();
    else dt = new Date(val);
    if (!dt || isNaN(dt)) return "-";
    const dd = String(dt.getDate()).padStart(2,"0");
    const mm = String(dt.getMonth()+1).padStart(2,"0");
    const yyyy = dt.getFullYear();
    let hh = dt.getHours();
    const min = String(dt.getMinutes()).padStart(2,"0");
    const ampm = hh >= 12 ? "PM" : "AM";
    hh = hh % 12; hh = hh ? hh : 12;
    hh = String(hh).padStart(2,"0");
    return `${dd}/${mm}/${yyyy} ${hh}:${min} ${ampm}`;
  }

  function initials(name){
    const n = String(name || "").trim();
    if (!n) return "ST";
    const parts = n.split(/\s+/).filter(Boolean);
    const a = parts[0]?.[0] || "S";
    const b = parts.length > 1 ? (parts[parts.length-1]?.[0] || "") : (parts[0]?.[1] || "");
    return (a + b).toUpperCase();
  }

  function formatLateMinutes(mins){
    const m = Math.max(0, Number(mins) || 0);
    const h = Math.floor(m / 60);
    const r = m % 60;
    if (h <= 0) return `${r}m`;
    if (r === 0) return `${h}h`;
    return `${h}h ${r}m`;
  }

  function computeArrivalStatusLine(row){
    const outVal = getOutDT(row);
    const out = new Date(String(outVal || ""));
    if (!outVal || isNaN(out)) return "";

    const now = new Date();
    if (now < out) return ""; // only after OUT time crossed

    const arrival = row.arrival || {};
    const verified = !!arrival.verified;
    if (!verified){
      return "⚠️ Student not yet reached back";
    }

    const verifiedAt = arrival.verified_at || arrival.verifiedAt || arrival.verified_time || "";
    const actual = arrival.actual_in_datetime || arrival.actualInDatetime || "";
    const lateMinutes = arrival.late_minutes ?? arrival.lateMinutes;

    const lateTxt = (lateMinutes != null) ? `Late by ${formatLateMinutes(lateMinutes)}` : "Late by —";
    const atTxt = verifiedAt ? fmtDT(verifiedAt) : (actual ? fmtDT(actual) : "—");
    return `✅ Reached • Verified at ${atTxt} • ${lateTxt}`;
  }

  function isWeekendBlock(outVal){
    const d = new Date(String(outVal || ""));
    if (isNaN(d)) return false;
    const dow = d.getDay(); // 0 Sun .. 6 Sat
    // Weekend = Fri + Sat only (as you defined)
    return dow === 5 || dow === 6;
  }

  function ordinal(n){
    const s=["th","st","nd","rd"], v=n%100;
    return n + (s[(v-20)%10]||s[v]||s[0]);
  }

  function monthKeyFromOut(outVal){
    const d = new Date(String(outVal||""));
    if (isNaN(d)) return "";
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    return `${y}-${m}`;
  }

  function chainEntryForMe(chain){
    const meLower = currentUserEmailLower;
    const meRaw = currentUserEmailRaw;
    const arr = Array.isArray(chain) ? chain : [];
    return arr.find(x => {
      const e = String(x?.email || "").trim();
      return e === meRaw || e.toLowerCase() === meLower;
    }) || null;
  }

  function didIAct(chain){
    const entry = chainEntryForMe(chain);
    if (!entry) return null;
    const st = String(entry.action || entry.status || "").toLowerCase();
    if (st === "approved") return "approved";
    if (st === "rejected") return "rejected";
    return null;
  }

  function isFinalApprovedStatus(st){
    const s = String(st || "").toLowerCase();
    return s === "approved_final" || s === "approved_dean_final";
  }

  function isFinalRejectedStatus(st){
    const s = String(st || "").toLowerCase();
    return s === "rejected_l1" || s === "rejected_dean";
  }

  function isPendingForMe(row){
    const holder = getCurrentHolderEmail(row);
    const holderOk = holder === currentUserEmailRaw || holder.toLowerCase() === currentUserEmailLower;
    const st = String(row.status || "").toLowerCase();
    return holderOk && (st === "pending_l1" || st === "pending_dean");
  }

  function computeCapabilitiesFromRoleDoc(d){
    const bcYears = Array.isArray(d?.bc_years) ? d.bc_years.map(x => String(x)) : [];
    const wardenHostels = Array.isArray(d?.warden_hostels) ? d.warden_hostels.map(x => String(x).toLowerCase()) : [];
    canBC = bcYears.some(y => y === "1" || y === "2");
    canWarden = wardenHostels.length > 0;
    canDean = (roleType === "dean");
    return { bcYears, wardenHostels };
  }

  function updateApproverUI(){
    const name = String(roleDoc?.name || "").trim() || (canDean ? "Dean" : "Approver");
    apName.textContent = name;
    apEmail.textContent = currentUserEmailRaw;

    const { bcYears, wardenHostels } = computeCapabilitiesFromRoleDoc(roleDoc);

    if (canDean){
      lineDean.style.display = "block";
      apDean.textContent = "Active";
    } else {
      lineDean.style.display = "none";
    }

    if (wardenHostels.length){
      lineWarden.style.display = "block";
      const pretty = wardenHostels.map(h => {
        if (h === "boys") return "Boys Hostel";
        if (h === "girls") return "Girls Hostel";
        if (h === "guest_house" || h === "guesthouse") return "Guest House";
        return h;
      }).join(", ");
      apWarden.textContent = pretty;
    } else {
      lineWarden.style.display = "none";
    }

    if (bcYears.some(y => y === "1" || y === "2")){
      lineBC.style.display = "block";
      const batches = bcYears
        .filter(y => y === "1" || y === "2")
        .map(y => YEAR_TO_BATCH[y] || `Year ${y}`)
        .join(", ");
      apBC.textContent = batches;
    } else {
      lineBC.style.display = "none";
    }
  }

  async function loadRoleDoc(){
    const refAdminLower = doc(db, "admins", currentUserEmailLower);
    const snapAdminLower = await getDoc(refAdminLower);
    if (snapAdminLower.exists()){
      roleType = "dean";
      return snapAdminLower.data();
    }

    const refAdminRaw = doc(db, "admins", currentUserEmailRaw);
    const snapAdminRaw = await getDoc(refAdminRaw);
    if (snapAdminRaw.exists()){
      roleType = "dean";
      return snapAdminRaw.data();
    }

    const refLower = doc(db, "approvers", currentUserEmailLower);
    const snapLower = await getDoc(refLower);
    if (snapLower.exists()){
      roleType = "approver";
      return snapLower.data();
    }

    const refRaw = doc(db, "approvers", currentUserEmailRaw);
    const snapRaw = await getDoc(refRaw);
    if (snapRaw.exists()){
      roleType = "approver";
      return snapRaw.data();
    }

    throw new Error("Access denied. You are not assigned as Batch Coordinator / Warden / Dean.");
  }

  async function tryGetDocs(qLower, qRaw){
    try{
      const snap = await getDocs(qLower);
      return snap.docs.map(d => ({ id: d.id, ...d.data() }));
    }catch(e){
      const snap2 = await getDocs(qRaw);
      return snap2.docs.map(d => ({ id: d.id, ...d.data() }));
    }
  }

  // ===== Photo helpers (same as your old) =====
  function extractDriveId(url){
    const u = String(url || "").trim();
    if (!u) return "";
    const m1 = u.match(/drive\.google\.com\/file\/d\/([^\/]+)\//);
    if (m1 && m1[1]) return m1[1];
    const m2 = u.match(/[?&]id=([^&]+)/);
    if (m2 && m2[1]) return m2[1];
    const m3 = u.match(/uc\?export=view&id=([^&]+)/);
    if (m3 && m3[1]) return m3[1];
    return "";
  }
  function resolveDriveUrls(rawLink){
    const id = extractDriveId(rawLink);
    if (!id) return { primary: rawLink, fallback: "" };
    const primary = `https://lh3.googleusercontent.com/d/${id}=w1000`;
    const fallback = `https://drive.google.com/uc?export=view&id=${id}`;
    return { primary, fallback };
  }

  function resolvePhotoURL(obj){
    const raw =
      obj?.photo_url ||
      obj?.photoUrl ||
      obj?.photoURL ||
      obj?.photo ||
      obj?.photoLink ||
      obj?.imageUrl ||
      obj?.imageURL ||
      obj?.student_photo_url ||
      "";

    const link = String(raw || "").trim();
    if (!link) return { primary:"", fallback:"" };

    if (link.includes("drive.google.com") || link.includes("googleusercontent.com")){
      return resolveDriveUrls(link);
    }
    if (link.startsWith("http://") || link.startsWith("https://")){
      return { primary: link, fallback: "" };
    }
    return { primary:"", fallback:"" };
  }

  async function getRosterPhotoResolved(rollno){
    const roll = normalizeRollno(rollno);
    if (!roll) return { primary:"", fallback:"" };
    if (rosterPhotoCache.has(roll)) return rosterPhotoCache.get(roll);

    try{
      const snap = await getDoc(doc(db, "students_roster", roll));
      if (!snap.exists()){
        const empty = { primary:"", fallback:"" };
        rosterPhotoCache.set(roll, empty);
        return empty;
      }
      const resolved = resolvePhotoURL(snap.data());
      rosterPhotoCache.set(roll, resolved);
      return resolved;
    }catch(e){
      const empty = { primary:"", fallback:"" };
      rosterPhotoCache.set(roll, empty);
      return empty;
    }
  }

  async function hydrateStudentPhoto(cardEl, rollno, studentName, requestRow){
    const img = cardEl.querySelector("img.studentPhoto");
    const av = cardEl.querySelector(".studentAvatar");
    if (!img || !av) return;

    av.textContent = initials(studentName);
    av.style.display = "grid";
    img.style.display = "none";

    let resolved = await getRosterPhotoResolved(rollno);
    if (!resolved?.primary){
      resolved = resolvePhotoURL(requestRow || {});
    }
    const { primary, fallback } = resolved || {};
    if (!primary) return;

    let usedFallback = false;

    img.onload = () => { img.style.display = "block"; av.style.display = "none"; };
    img.onerror = () => {
      if (!usedFallback && fallback){ usedFallback = true; img.src = fallback; return; }
      img.style.display = "none"; av.style.display = "grid";
    };

    img.src = primary;
  }

  // ===== Cache refresh (new statuses) =====
  async function refreshCache(){
    const meLower = currentUserEmailLower;
    const meRaw = currentUserEmailRaw;

    // Pending assigned to me
    const qPendingLower = query(collection(db, "leave_requests"),
      where("current.holder_email", "==", meLower)
    );
    const qPendingRaw = query(collection(db, "leave_requests"),
      where("current.holder_email", "==", meRaw)
    );
    const pendingRows = await tryGetDocs(qPendingLower, qPendingRaw);

    // All my-involved (history)
    const qMineLower = query(collection(db, "leave_requests"),
      where("approver_emails", "array-contains", meLower)
    );
    const qMineRaw = query(collection(db, "leave_requests"),
      where("approver_emails", "array-contains", meRaw)
    );
    let mineAll = [];
    try { mineAll = await tryGetDocs(qMineLower, qMineRaw); }
    catch(e){ mineAll = []; }

    // Keep:
    // - pending for me
    // - anything where I approved/rejected
    // - anything escalated (requested true) where I'm in chain (for escalated history)
    const actedOrEscalated = mineAll.filter(r => {
      const acted = didIAct(r.approver_chain);
      if (acted) return true;
      if (r?.escalation?.requested) return true;
      return false;
    });

    const map = new Map();
    [...pendingRows, ...actedOrEscalated].forEach(r => map.set(r.id, r));
    cacheAllForApprover = [...map.values()];
  }

  function computeDashboardMetrics(){
    const meLower = currentUserEmailLower;
    const meRaw = currentUserEmailRaw;

    const rows = cacheAllForApprover.filter(r => {
      if (!inDateRangeOutDT(r, dashFrom, dashTo)) return false;
      return true;
    });

    const total = rows.length;

    const pending = rows.filter(r => isPendingForMe(r)).length;

    const approved = rows.filter(r => {
      const acted = didIAct(r.approver_chain);
      return acted === "approved";
    }).length;

    const rejected = rows.filter(r => {
      const acted = didIAct(r.approver_chain);
      return acted === "rejected";
    }).length;

    mTotal.textContent = String(total);
    mPending.textContent = String(pending);
    mApproved.textContent = String(approved);
    mRejected.textContent = String(rejected);
  }

  // ===== Weekend Approved Counter (Fri+Sat, final approved only) =====
  function buildWeekendApprovedCounters(){
    // Map: monthKey -> roll -> countIndex
    const counters = new Map(); // monthKey -> Map(roll -> n)
    const indexForRequest = new Map(); // requestId -> index

    // Consider only final approved
    const rows = cacheAllForApprover
      .filter(r => isFinalApprovedStatus(r.status))
      .filter(r => isWeekendBlock(getOutDT(r)));

    // sort by out_datetime asc so 1st approved weekend is stable
    rows.sort((a,b) => String(getOutDT(a)||"").localeCompare(String(getOutDT(b)||"")));

    for (const r of rows){
      const roll = normalizeRollno(r.student_rollno || "");
      const mk = r.month_key || monthKeyFromOut(getOutDT(r)) || "";
      if (!roll || !mk) continue;

      if (!counters.has(mk)) counters.set(mk, new Map());
      const mm = counters.get(mk);

      const prev = mm.get(roll) || 0;
      const next = prev + 1;
      mm.set(roll, next);
      indexForRequest.set(r.id, next);
    }

    return indexForRequest;
  }

  // ===== Render Pending Requests =====
  function renderPendingRequests(){
    const rows = cacheAllForApprover
      .filter(r => isPendingForMe(r))
      .filter(r => inDateRangeOutDT(r, reqFrom, reqTo));

    // sort newest out first
    rows.sort((a,b) => String(getOutDT(b)||"").localeCompare(String(getOutDT(a)||"")));

    requestsContainer.innerHTML = "";

    if (!rows.length){
      const empty = document.createElement("div");
      empty.style.padding = "14px";
      empty.style.color = "#64748b";
      empty.style.fontWeight = "850";
      empty.textContent = "No pending requests assigned to you.";
      requestsContainer.appendChild(empty);
      return;
    }

    const weekendIndex = buildWeekendApprovedCounters();

    rows.forEach(r => {
      const st = String(r.status || "").toLowerCase();
      const badgeClass = (st.includes("pending")) ? "pending" : (st.includes("approved") ? "approved" : "rejected");

      const studentName = r.student_name || "—";
      const roll = normalizeRollno(r.student_rollno || "");
      const room = r.student_room_no || "—";

      const reasonCat = String(r.reason_category || r.reasonCategory || "—").trim();
      const reasonTxt = String(r.reason_text || r.reasonText || r.reason || "").trim();
      const reasonLine = reasonTxt ? `${reasonCat} — ${reasonTxt}` : reasonCat;

      const outVal = getOutDT(r);
      const inVal  = getInDT(r);

      const arrivalLine = computeArrivalStatusLine(r);

      // Escalation checkbox only for L1 (BC/Warden) and only if current stage is L1
      const holderRole = getCurrentHolderRole(r).toLowerCase();
      const canEscalate = (holderRole === "batch_coordinator" || holderRole === "warden") && !!(r.routing && r.routing.dean_email);

      const remarkId = `remark_${r.id}`;
      const escId = `esc_${r.id}`;

      const weekendTag = isWeekendBlock(outVal) ? "WEEKEND BLOCK (Fri/Sat)" : "WEEKDAY";

      const card = document.createElement("section");
      card.className = "requestCard";
      card.innerHTML = `
        <div class="cardTop">
          <div class="studentBlock">
            <img class="studentPhoto" src="${IMG_PLACEHOLDER}" alt="Student photo" style="display:none;">
            <div class="studentAvatar">${initials(studentName)}</div>
            <div class="studentText">
              <div class="studentName">${studentName}</div>
              <div class="studentMeta">${(roll||"—")} • Room ${room} • ${weekendTag}</div>
              ${arrivalLine ? `<div class="reqCountLine">${arrivalLine}</div>` : ``}
            </div>
          </div>
          <div class="badge ${badgeClass}">${st.toUpperCase()}</div>
        </div>

        <div class="details">
          <div class="kv"><div class="k">OUT DATE & TIME</div><div class="v">${fmtDT(outVal)}</div></div>
          <div class="kv"><div class="k">IN DATE & TIME</div><div class="v">${fmtDT(inVal)}</div></div>
          <div class="kv reasonBox"><div class="k">REASON</div><div class="v">${reasonLine || "-"}</div></div>
        </div>

        <textarea id="${remarkId}" placeholder="Remark (optional)"></textarea>

        ${canEscalate ? `
          <label class="inlineOpt">
            <input type="checkbox" id="${escId}">
            Escalate to Dean after my approval
          </label>
        ` : ``}

        <div class="actions">
          <button class="actionBtn approveBtn" data-id="${r.id}" type="button">Approve</button>
          <button class="actionBtn rejectBtn" data-id="${r.id}" type="button">Reject</button>
        </div>
      `;

      requestsContainer.appendChild(card);
      hydrateStudentPhoto(card, roll, studentName, r);
    });

    requestsContainer.querySelectorAll(".approveBtn").forEach(btn => {
      btn.addEventListener("click", () => handleApprove(btn.dataset.id));
    });
    requestsContainer.querySelectorAll(".rejectBtn").forEach(btn => {
      btn.addEventListener("click", () => handleReject(btn.dataset.id));
    });
  }

  // ===== History Render =====
  function setHistoryTab(which){
    activeHistoryTab = which;
    [hApproved, hRejected, hEscalated].forEach(x => x.classList.remove("active"));
    if (which === "approved") hApproved.classList.add("active");
    if (which === "rejected") hRejected.classList.add("active");
    if (which === "escalated") hEscalated.classList.add("active");
    renderHistory();
  }

  function renderHistory(){
    let rows = cacheAllForApprover.slice();

    if (activeHistoryTab === "approved"){
      rows = rows.filter(r => didIAct(r.approver_chain) === "approved");
    } else if (activeHistoryTab === "rejected"){
      rows = rows.filter(r => didIAct(r.approver_chain) === "rejected");
    } else {
      // escalated: show pending + dean-approved + dean-rejected
      rows = rows.filter(r => !!(r?.escalation?.requested));
    }

    // Sort newest out first
    rows.sort((a,b) => String(getOutDT(b)||"").localeCompare(String(getOutDT(a)||"")));

    // Counts
    hcApproved.textContent = String(cacheAllForApprover.filter(r => didIAct(r.approver_chain) === "approved").length);
    hcRejected.textContent = String(cacheAllForApprover.filter(r => didIAct(r.approver_chain) === "rejected").length);
    hcEscalated.textContent = String(cacheAllForApprover.filter(r => !!(r?.escalation?.requested)).length);

    historyContainer.innerHTML = "";

    if (!rows.length){
      const empty = document.createElement("div");
      empty.style.padding = "14px";
      empty.style.color = "#64748b";
      empty.style.fontWeight = "850";
      empty.textContent = "No records found.";
      historyContainer.appendChild(empty);
      return;
    }

    const weekendIndex = buildWeekendApprovedCounters();

    for (const r of rows){
      const st = String(r.status || "").toLowerCase();
      const badgeClass =
        st.includes("pending") ? "pending" :
        st.includes("approved") ? "approved" :
        st.includes("rejected") ? "rejected" : "pending";

      const studentName = r.student_name || "—";
      const roll = normalizeRollno(r.student_rollno || "");
      const room = r.student_room_no || "—";

      const reasonCat = String(r.reason_category || "—").trim();
      const reasonTxt = String(r.reason_text || r.reason || "").trim();
      const reasonLine = reasonTxt ? `${reasonCat} — ${reasonTxt}` : reasonCat;

      const outVal = getOutDT(r);
      const inVal  = getInDT(r);

      const arrivalLine = computeArrivalStatusLine(r);

      // weekend approved count line (only meaningful for weekend leaves)
      let reqCountHTML = "";
      if (isWeekendBlock(outVal) && isFinalApprovedStatus(r.status)){
        const idx = weekendIndex.get(r.id) || 1;
        reqCountHTML = `<div class="reqCountLine">${ordinal(idx)} weekend request of the month</div>`;
      }

      const card = document.createElement("section");
      card.className = "requestCard";
      card.innerHTML = `
        <div class="cardTop">
          <div class="studentBlock">
            <img class="studentPhoto" src="${IMG_PLACEHOLDER}" alt="Student photo" style="display:none;">
            <div class="studentAvatar">${initials(studentName)}</div>
            <div class="studentText">
              <div class="studentName">${studentName}</div>
              <div class="studentMeta">${(roll||"—")} • Room ${room}</div>
              ${reqCountHTML}
              ${arrivalLine ? `<div class="reqCountLine">${arrivalLine}</div>` : ``}
            </div>
          </div>
          <div class="badge ${badgeClass}">${st.toUpperCase()}</div>
        </div>

        <div class="details">
          <div class="kv"><div class="k">OUT DATE & TIME</div><div class="v">${fmtDT(outVal)}</div></div>
          <div class="kv"><div class="k">IN DATE & TIME</div><div class="v">${fmtDT(inVal)}</div></div>
          <div class="kv reasonBox"><div class="k">REASON</div><div class="v">${reasonLine || "-"}</div></div>
        </div>
      `;
      historyContainer.appendChild(card);
      hydrateStudentPhoto(card, roll, studentName, r);
    }
  }

  // ===== Gatepass Public =====
  async function upsertPublicGatepass(requestId, requestRow){
    const outVal = getOutDT(requestRow);
    const inVal = getInDT(requestRow);

    const payload = {
      status: "approved",
      approved_public_at: isoNow(),
      student_name: requestRow.student_name || "",
      student_rollno: requestRow.student_rollno || "",
      student_room_no: requestRow.student_room_no || "",
      student_email: requestRow.student_email || "",
      student_uid: requestRow.student_uid || "",
      out_datetime: outVal || "",
      in_datetime: inVal || "",
      reason_category: requestRow.reason_category || "",
      reason_text: requestRow.reason_text || requestRow.reason || "",
      contact_no: requestRow.contact_no || "",
      photo_url: requestRow.student_photo_url || requestRow.photo_url || "",
      updatedAt: serverTimestamp(),
      updated_at: serverTimestamp()
    };

    await setDoc(doc(db, "gatepass_public", requestId), payload, { merge: true });
  }

  // ===== Approve / Reject (new routing policy) =====
  function ensureDeanStage(chain, deanEmail){
    const arr = Array.isArray(chain) ? [...chain] : [];
    const exists = arr.some(x => String(x?.role || "").toLowerCase() === "dean");
    if (exists) return arr;

    const nextStage = arr.length ? Math.max(...arr.map(x => Number(x.stage)||0)) + 1 : 2;
    arr.push({
      stage: nextStage,
      role: "dean",
      email: normalizeEmail(deanEmail),
      action: "pending",
      acted_at: null,
      remark: ""
    });
    return arr;
  }

  function markMyChainAction(chain, action, remark){
    const arr = Array.isArray(chain) ? [...chain] : [];
    const meLower = currentUserEmailLower;
    const meRaw = currentUserEmailRaw;

    let idx = arr.findIndex(x => {
      const e = String(x?.email || "").trim();
      const ok = e === meRaw || e.toLowerCase() === meLower;
      const st = String(x?.action || x?.status || "").toLowerCase();
      return ok && (st === "pending" || st === ""); // pending stage for me
    });

    if (idx === -1){
      // fallback: any entry for me
      idx = arr.findIndex(x => {
        const e = String(x?.email || "").trim();
        return e === meRaw || e.toLowerCase() === meLower;
      });
    }

    if (idx >= 0){
      arr[idx] = { ...arr[idx], action, status: action, acted_at: isoNow(), actedAt: isoNow(), remark: remark || "" };
    } else {
      arr.push({
        stage: arr.length + 1,
        role: canDean ? "dean" : "approver_override",
        email: meLower,
        action,
        status: action,
        acted_at: isoNow(),
        remark: remark || ""
      });
    }

    return arr;
  }

  async function handleApprove(requestId){
    const r = cacheAllForApprover.find(x => x.id === requestId);
    if (!r) return;

    if (!isPendingForMe(r)) return;

    const st = String(r.status || "").toLowerCase();
    const holderRole = getCurrentHolderRole(r).toLowerCase();

    const remark = (document.getElementById(`remark_${requestId}`)?.value || "").trim();
    const chain0 = Array.isArray(r.approver_chain) ? r.approver_chain : [];
    let chain = markMyChainAction(chain0, "approved", remark);

    const updates = {
      approver_chain: chain,
      approver_emails: (Array.isArray(r.approver_emails) ? r.approver_emails : []).length ? r.approver_emails : chain.map(x => normalizeEmail(x.email)).filter(Boolean),
      updated_at: serverTimestamp(),
      updatedAt: serverTimestamp()
    };

    let finalApproved = false;

    // If Dean is approving (pending_dean) => final approved by dean
    if (holderRole === "dean" || st === "pending_dean"){
      updates.status = "approved_dean_final";
      updates.current = { holder_email: null, holder_role: "", stage: "" };
      updates.current_holder_email = null;

      updates.escalation = {
        ...(r.escalation || {}),
        dean_action: "approved"
      };

      finalApproved = true;
    } else {
      // L1 approving
      const deanEmail = r?.routing?.dean_email || "";
      const escEl = document.getElementById(`esc_${requestId}`);
      const wantEsc = !!(escEl && escEl.checked);

      if (wantEsc && deanEmail){
        // escalate to dean
        chain = ensureDeanStage(chain, deanEmail);
        updates.approver_chain = chain;
        updates.status = "pending_dean";
        updates.current = { holder_email: normalizeEmail(deanEmail), holder_role: "dean", stage: "DEAN" };
        updates.current_holder_email = normalizeEmail(deanEmail);

        updates.escalation = {
          ...(r.escalation || {}),
          requested: true,
          requested_by: currentUserEmailLower,
          requested_at: serverTimestamp(),
          reason: ""
        };
      } else {
        // final approved at L1
        updates.status = "approved_final";
        updates.current = { holder_email: null, holder_role: "", stage: "" };
        updates.current_holder_email = null;

        updates.escalation = {
          ...(r.escalation || {}),
          requested: false,
          dean_action: "not_required"
        };

        finalApproved = true;
      }
    }

    try{
      await updateDoc(doc(db, "leave_requests", requestId), updates);

      if (finalApproved){
        await upsertPublicGatepass(requestId, { ...r, ...updates });
      }

      await refreshCache();
      computeDashboardMetrics();
      renderPendingRequests();
      renderHistory();
      updateHistoryCounts();
    }catch(e){
      console.error(e);
      alert("Unable to approve. Check Firestore rules / indexes.");
    }
  }

  async function handleReject(requestId){
    const r = cacheAllForApprover.find(x => x.id === requestId);
    if (!r) return;

    if (!isPendingForMe(r)) return;

    const st = String(r.status || "").toLowerCase();
    const holderRole = getCurrentHolderRole(r).toLowerCase();

    const remark = (document.getElementById(`remark_${requestId}`)?.value || "").trim();
    const chain0 = Array.isArray(r.approver_chain) ? r.approver_chain : [];
    const chain = markMyChainAction(chain0, "rejected", remark);

    const updates = {
      approver_chain: chain,
      approver_emails: (Array.isArray(r.approver_emails) ? r.approver_emails : []).length ? r.approver_emails : chain.map(x => normalizeEmail(x.email)).filter(Boolean),
      updated_at: serverTimestamp(),
      updatedAt: serverTimestamp(),
      current: { holder_email: null, holder_role: "", stage: "" },
      current_holder_email: null
    };

    if (holderRole === "dean" || st === "pending_dean"){
      updates.status = "rejected_dean";
      updates.escalation = {
        ...(r.escalation || {}),
        dean_action: "rejected"
      };
    } else {
      updates.status = "rejected_l1";
      // if it was escalated before reject (rare), still show in escalated history
      updates.escalation = {
        ...(r.escalation || {}),
        dean_action: r?.escalation?.requested ? "pending" : "not_required"
      };
    }

    try{
      await updateDoc(doc(db, "leave_requests", requestId), updates);

      await refreshCache();
      computeDashboardMetrics();
      renderPendingRequests();
      renderHistory();
      updateHistoryCounts();
    }catch(e){
      console.error(e);
      alert("Unable to reject. Check Firestore rules / indexes.");
    }
  }

  // ===== History counts =====
  function updateHistoryCounts(){
    hcApproved.textContent = String(cacheAllForApprover.filter(r => didIAct(r.approver_chain) === "approved").length);
    hcRejected.textContent = String(cacheAllForApprover.filter(r => didIAct(r.approver_chain) === "rejected").length);
    hcEscalated.textContent = String(cacheAllForApprover.filter(r => !!(r?.escalation?.requested)).length);
  }

  // ===== Buttons / events =====
  logoutBtn.addEventListener("click", async () => {
    try{ await signOut(auth); }catch(_){}
    window.location.replace("../index.html");
  });

  tabDashboard.addEventListener("click", () => showPage("dashboard"));
  tabRequests.addEventListener("click", () => {
    showPage("requests");
    renderPendingRequests();
  });
  tabHistory.addEventListener("click", () => {
    showPage("history");
    renderHistory();
  });

  applyFilters.addEventListener("click", async () => {
    dashFrom = fFrom.value || "";
    dashTo = fTo.value || "";
    await refreshCache();
    computeDashboardMetrics();
    updateHistoryCounts();
  });

  applyReqFilters.addEventListener("click", () => {
    reqFrom = rFrom.value || "";
    reqTo = rTo.value || "";
    renderPendingRequests();
  });

  // History tab events
  hApproved.addEventListener("click", () => setHistoryTab("approved"));
  hRejected.addEventListener("click", () => setHistoryTab("rejected"));
  hEscalated.addEventListener("click", () => setHistoryTab("escalated"));

  // ===== Reports UI =====
  function setRepMode(mode){
    repMode = mode;
    repModeTime.classList.toggle("active", mode === "time");
    repModeStudent.classList.toggle("active", mode === "student");
    repRollBox.style.display = (mode === "student") ? "block" : "none";
    clearToast(repToast);
  }
  repModeTime.addEventListener("click", () => setRepMode("time"));
  repModeStudent.addEventListener("click", () => setRepMode("student"));

  function todayDateStr(){
    const d = new Date();
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    return `${yyyy}-${mm}-${dd}`;
  }
  function addDays(dateObj, days){
    const d = new Date(dateObj);
    d.setDate(d.getDate() + days);
    return d;
  }
  function dateToStr(d){
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const dd = String(d.getDate()).padStart(2,"0");
    return `${yyyy}-${mm}-${dd}`;
  }
  function applyPreset(days){
    const now = new Date();
    const from = addDays(now, -days);
    repFrom.value = dateToStr(from);
    repTo.value = todayDateStr();
    clearToast(repToast);
  }
  repPreset7.addEventListener("click", () => applyPreset(7));
  repPreset30.addEventListener("click", () => applyPreset(30));
  repPresetThisMonth.addEventListener("click", () => {
    const now = new Date();
    const first = new Date(now.getFullYear(), now.getMonth(), 1);
    repFrom.value = dateToStr(first);
    repTo.value = todayDateStr();
    clearToast(repToast);
  });

  repClear.addEventListener("click", () => {
    repFrom.value = "";
    repTo.value = "";
    repYear.value = "all";
    repRoll.value = "";
    setRepMode("time");
    clearToast(repToast);
  });

  function getStudentYear(row){
    return String(row.student_year ?? row.studentYear ?? "").trim();
  }

  async function fetchFinalApprovedRowsForReport({ fromDate, toDate, year, roll }){
    const meLower = currentUserEmailLower;

    const fromISO = toStartOfDayISO(fromDate);
    const toISO = toEndOfDayISO(toDate);

    if (!fromDate || !toDate) throw new Error("Please select From & To dates (IN datetime).");

    // Firestore: status == approved_final OR approved_dean_final cannot be done in single query without OR.
    // So fetch my scope in date range, then filter in JS.
    const baseQ = query(
      collection(db, "leave_requests"),
      where("approver_emails", "array-contains", meLower),
      where("in_datetime", ">=", fromISO),
      where("in_datetime", "<=", toISO)
    );

    const snap = await getDocs(baseQ);
    let rows = snap.docs.map(d => ({ id: d.id, ...d.data() }));

    rows = rows.filter(r => isFinalApprovedStatus(r.status));
    rows = rows.filter(r => didIAct(r.approver_chain) === "approved");

    if (year && year !== "all"){
      rows = rows.filter(r => String(getStudentYear(r)) === String(year));
    }
    if (roll){
      const rr = normalizeRollno(roll);
      rows = rows.filter(r => normalizeRollno(r.student_rollno || "") === rr);
    }

    rows.sort((a,b) => String(getInDT(a)||"").localeCompare(String(getInDT(b)||"")));
    return rows;
  }

  function buildReportFilename({ mode, fromDate, toDate, roll }){
    const role = (roleType === "dean") ? "Dean" : "Approver";
    const base = `${role}_Report_${fromDate}_to_${toDate}`;
    if (mode === "student" && roll) return `${base}_${normalizeRollno(roll)}.pdf`;
    return `${base}.pdf`;
  }

  function buildPDF({ rows, mode, fromDate, toDate, year, roll }){
    const { jsPDF } = window.jspdf;
    const docPDF = new jsPDF({ orientation: "portrait", unit: "pt", format: "a4" });
    const pageW = docPDF.internal.pageSize.getWidth();

    docPDF.setFont("helvetica", "bold");
    docPDF.setFontSize(14);
    docPDF.text("Xavier Institute of Management and Entrepreneurship (XIME)", 40, 42);

    docPDF.setFontSize(12);
    docPDF.setTextColor(193, 18, 31);
    docPDF.text("Leave Management System — Final Approved Requests Report", 40, 62);
    docPDF.setTextColor(15, 23, 42);

    docPDF.setDrawColor(193, 18, 31);
    docPDF.setLineWidth(2);
    docPDF.line(40, 74, pageW - 40, 74);

    docPDF.setFont("helvetica", "normal");
    docPDF.setFontSize(10);

    const genAt = new Date().toLocaleString();
    const who = `${apName.textContent || "Approver"} (${currentUserEmailRaw})`;
    const yearText = (year && year !== "all") ? `Year ${year}` : "All Years";

    const lines = [
      `Prepared by: ${who}`,
      `Generated: ${genAt}`,
      `IN datetime range: ${fromDate} to ${toDate}`,
      `Year Filter: ${yearText}`,
      mode === "student" ? `Student Roll No: ${normalizeRollno(roll || "")}` : `Mode: Timeframe (All Final Approved by Me)`,
    ];

    let y = 92;
    lines.forEach((t) => { docPDF.text(t, 40, y); y += 14; });

    const lateRows = rows.filter(r => {
      const late = r?.arrival?.late_minutes ?? r?.arrival?.lateMinutes ?? 0;
      const verified = !!(r?.arrival?.verified);
      return verified && (Number(late) > 0);
    });

    docPDF.setFont("helvetica", "bold");
    docPDF.text(`Total Records: ${rows.length}    Late Comers (verified & late): ${lateRows.length}`, 40, y + 6);
    docPDF.setFont("helvetica", "normal");

    const tableBody = rows.map((r, idx) => {
      const studentName = r.student_name || "";
      const rollno = normalizeRollno(r.student_rollno || "");
      const yearVal = getStudentYear(r) || "";
      const hostel = String(r.student_hostel || "").trim();
      const room = String(r.student_room_no || "").trim();
      const outVal = getOutDT(r);
      const inVal  = getInDT(r);
      const contact = String(r.contact_no || "").trim();

      const actualIn = r?.arrival?.actual_in_datetime || "";
      const lateMins = r?.arrival?.late_minutes ?? null;
      const actualInTxt = actualIn ? fmtDT(actualIn) : "—";
      const lateTxt = (lateMins != null && Number(lateMins) > 0) ? formatLateMinutes(lateMins) : "—";

      const reasonCat = String(r.reason_category || "—").trim();
      const reasonTxt = String(r.reason_text || r.reason || "").trim();
      const reason = reasonTxt ? `${reasonCat} — ${reasonTxt}` : reasonCat;

      return [
        String(idx + 1),
        rollno || "—",
        studentName || "—",
        yearVal || "—",
        hostel || "—",
        room || "—",
        fmtDT(outVal),
        fmtDT(inVal),
        actualInTxt,
        lateTxt,
        contact || "—",
        reason || "—"
      ];
    });

    docPDF.autoTable({
      startY: y + 18,
      head: [[
        "S.No","Roll No","Student Name","Year","Hostel","Room",
        "Out Date & Time","In Date & Time","Actual In Time","Late By","Contact","Reason"
      ]],
      body: tableBody,
      styles: { font: "helvetica", fontSize: 8, cellPadding: 4, overflow: "linebreak" },
      headStyles: { fillColor: [193, 18, 31], textColor: 255, fontStyle: "bold" },
      alternateRowStyles: { fillColor: [248, 250, 252] },
      margin: { left: 40, right: 40 },
      theme: "striped",
      didDrawPage: () => {
        const pageCount = docPDF.internal.getNumberOfPages();
        const pageCurrent = docPDF.internal.getCurrentPageInfo().pageNumber;
        docPDF.setFontSize(9);
        docPDF.setTextColor(100);
        docPDF.text(`Page ${pageCurrent} of ${pageCount}`, pageW - 90, docPDF.internal.pageSize.getHeight() - 20);
        docPDF.setTextColor(15, 23, 42);
      }
    });

    // Late Comers list section
    if (lateRows.length){
      docPDF.addPage();
      docPDF.setFont("helvetica", "bold");
      docPDF.setFontSize(12);
      docPDF.setTextColor(193,18,31);
      docPDF.text("Late Comers List (Verified & Late > 0)", 40, 50);
      docPDF.setTextColor(15,23,42);

      const body2 = lateRows.map((r, i) => {
        const rollno = normalizeRollno(r.student_rollno || "");
        const name = r.student_name || "—";
        const plannedIn = getInDT(r);
        const actualIn = r?.arrival?.actual_in_datetime || "";
        const lateMins = r?.arrival?.late_minutes ?? 0;
        return [
          String(i+1),
          rollno,
          name,
          fmtDT(plannedIn),
          actualIn ? fmtDT(actualIn) : "—",
          formatLateMinutes(lateMins)
        ];
      });

      docPDF.autoTable({
        startY: 70,
        head: [["S.No","Roll No","Student Name","Planned In Time","Actual In Time","Late By"]],
        body: body2,
        styles: { font: "helvetica", fontSize: 9, cellPadding: 5, overflow: "linebreak" },
        headStyles: { fillColor: [193, 18, 31], textColor: 255, fontStyle: "bold" },
        alternateRowStyles: { fillColor: [248, 250, 252] },
        margin: { left: 40, right: 40 },
        theme: "striped"
      });
    }

    return docPDF;
  }

  repDownload.addEventListener("click", async () => {
    clearToast(repToast);

    try{
      repDownload.disabled = true;

      const fromDate = repFrom.value || "";
      const toDate = repTo.value || "";
      const year = repYear.value || "all";
      const roll = (repMode === "student") ? (repRoll.value || "") : "";

      if (repMode === "student" && !roll.trim()){
        showToast(repToast, "Enter Student Roll No for Student-wise report.", "bad");
        return;
      }

      showToast(repToast, "Preparing report…", "good");

      const rows = await fetchFinalApprovedRowsForReport({ fromDate, toDate, year, roll });

      if (!rows.length){
        showToast(repToast, "No final approved records found for the selected filters.", "bad");
        return;
      }

      const pdf = buildPDF({ rows, mode: repMode, fromDate, toDate, year, roll });
      const filename = buildReportFilename({ mode: repMode, fromDate, toDate, roll });

      pdf.save(filename);
      showToast(repToast, "Downloaded successfully ✅", "good");

    }catch(err){
      console.error(err);
      showToast(repToast, err?.message || "Unable to generate report. Check Firestore indexes / permissions.", "bad");
    }finally{
      repDownload.disabled = false;
    }
  });

  // ===== Auth boot =====
  onAuthStateChanged(auth, async (u) => {
    if (!u){
      window.location.replace("../index.html");
      return;
    }

    currentUserEmailRaw = String(u.email || "").trim();
    currentUserEmailLower = currentUserEmailRaw.toLowerCase();

    try{
      roleDoc = await loadRoleDoc();

      if (roleDoc?.is_active === false){
        throw new Error("Access denied. Your account is inactive.");
      }

      computeCapabilitiesFromRoleDoc(roleDoc);

      if (!canBC && !canWarden && !canDean){
        throw new Error("Access denied. You are not assigned as Batch Coordinator / Warden / Dean.");
      }

      updateApproverUI();
      showPage("dashboard");

      // default report dates: this month
      const now = new Date();
      const first = new Date(now.getFullYear(), now.getMonth(), 1);
      repFrom.value = dateToStr(first);
      repTo.value = todayDateStr();
      setRepMode("time");

      await refreshCache();
      computeDashboardMetrics();
      updateHistoryCounts();
      renderPendingRequests();
      renderHistory();

    }catch(err){
      console.error(err);
      alert(err?.message || "Unable to load approver role/data. Contact Admin.");
      try{ await signOut(auth); }catch(_){}
      window.location.replace("../index.html");
    }
  });
</script>
</body>
</html>
